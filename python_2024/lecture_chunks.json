[
    "Python\nschnell und intensiv Programmieren lernen\nBerry Boessenkool\n frei verwenden, zitieren 2024-10-30 21:12\nPython MOOC TOC 1/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.1 Willkommen TOC 2/ 145\nWillkommen\n▶Berry\n▶2008-2017 Geo¨ okologie @ Uni Potsdam\n▶”versehentlich” ein\n -Fan geworden\n▶Pakete\n ,Community\n ,Training & Beratung\n▶seit 2019 in Teilzeit Dozent am HPI (Lehrstuhl Bert Arnrich)\n▶seit 2021 auch\n -Unterricht\nPython MOOC - 1.1 Willkommen TOC 3/ 145\nKursphilosophie\n▶Python Grundlagen in z¨ ugigem Tempo\n▶Rechne mit 5-10 Stunden Aufwand pro Woche! ▶Trotz KI-Assistenten: selbst programmieren (lernen) k¨ onnen\n▶Ziel: effizient und reproduzierbar arbeiten\n▶Python Eigenschaften (Quelle):\n▶interpretierte Sprache (keine Kompilierung)\n▶dynamische Typisierung (Datentypen werden zur Laufzeit ¨ uberpr¨ uft)\n▶objektorientiert (Daten mit Methoden)\n▶high-level (von Menschen lesbar)\n▶Eingesetzt in Data Science, Machine Learning, Webentwicklung,\nSpielentwicklung, Robotik, autonome Fahrzeuge, Entwicklung\ngraphischer Nutzeroberfl¨ achen, Finanzwesen, ... Python MOOC - 1.1 Willkommen TOC 4/ 145\nKursablauf\n▶14 Lektionen\n▶Video\n▶PDF (pro Woche KursPDF mit allen Folien) mit\n# Python Code auf grauem Hintergrund\n▶Multiple Choice Quiz (Selbsttest)\n▶Automatisch bewertete Programmieraufgaben\n▶Zeit und Dauer der Bearbeitung frei w¨ ahlbar\n▶Kursinhalte in der Kursbeschreibung\n▶pro Kurswoche (f¨ ur einen Leistungsnachweis)\n▶Multiple Choice Quiz (Hausaufgabe)\n▶Nach Beginn 60 Minuten Zeit\n▶Fragen\n▶Kursforum [Diskussionen] + Kommentaranfragen\n▶Themenbezogene Fragen unter den Videos stellen\n▶Beitragstitel zum leichten Suchen im Format \"1.3 A5\" beginnen\n▶Gegenseitig beantworten und intensiver lernen! Python MOOC - 1.1 Willkommen TOC 5/ 145\nRessourcen\n▶Download & Installation, Hinweise f¨ ur Windows\n▶offizielle Dokumentation und Sprachreferenz\n▶Drucken: RefCard , zB. Laurent Pointal , Berry (nah am Kurs), Suche\n▶codingame.com: Programmierwettbewerbe mit Suchtpotenzial\n▶Ausf¨ uhrlichere (langsamere) Kurse:\n▶openHPI deutscher Python Junior Kurs\n▶bodenseo deutsche Webseite + Buch\n▶Computer Science Circles interaktiver englischer Kurs\n▶Python.org offizielles englisches Tutorial\nPython MOOC - 1.1 Willkommen TOC 6/ 145\nIntegrated development environment (IDE)\n▶Programmieraufgaben sind im Browser l¨ osbar\n▶Im echten Leben lokal arbeiten - in einer Entwicklungsumgebung\n▶F¨ ur Python gibt es Hunderte IDEs (Top 9, RStudio)\n▶Ich empfehle VS Code (ggf. Telemetry ausschalten)\n▶f¨ ur viele Sprachen, z.B. Python, R, Julia, JavaScript, C++, SQL\n▶kann Script ausf¨ uhren oder einzelne Zeilen (Demo)\n▶Wer’s braucht: Jupyter notebooks (Julia, Python, R) , zB.",
    "google\nPython MOOC - 1.1 Willkommen TOC 7/ 145\nProgrammieraufgaben\nZu jeder Lektion gibt es interaktive Code-aufgaben im Browser. Der Zugang erfolgt via openHPI (nicht direkt per URL). Python MOOC - 1.1 Willkommen TOC 8/ 145\nProgrammieraufgaben in CodeOcean\n1. Runterladen (lokal bearbeiten)\n2. Alle Skripte dieser Lektion (heißt hier ”Aufgabe”) zur¨ ucksetzen\n3. Skript ausf¨ uhren lassen\n4. Komplette Aufgabe bewerten lassen\n5. Kommentaranfrage stellen (f¨ ur individuelle Hilfe)\n6. (unten): ein einzelnes Skript zur¨ ucksetzen\nPython MOOC - 1.1 Willkommen TOC 9/ 145\nProgrammieraufgaben Hinweise\nSollte beim Bewerten rechts unten mal ERROR: test** statt FAIL: stehen,\nbitte den Fehler verzeihen und die Nachricht im Forum melden. Es ist nicht n¨ otig, 100% zu erreichen um mit anderen Aufgaben im Kurs\nweiterzumachen. Ich teile keine geb¨ undelten Musterl¨ osungen:\n▶es schr¨ ankt deine Kreativit¨ at und Diversit¨ at ein (es gibt meistens mehrere\nL¨ osungswege)\n▶es geht viel Lerneffekt verloren, wenn man dann doch ”kurz reinschaut”\n▶du musst unbedingt lernen, selbst L¨ osungen zu finden\n▶zu einzelnen Aufgaben darfst du im Forum nach besseren Ans¨ atzen fragen\n(didaktisch wertvoll). Schaue auch gerne in die Kommentaranfragen\nanderer Teilnehmer rein. ▶das Testskript schaut bereits, ob deine L¨ osung generalisiert anwendbar ist\n▶Good Coding ist eine Stilfrage, wo ich nicht allzuviel vorschreiben m¨ ochte\nPython MOOC - 1.1 Willkommen TOC 10/ 145\nZusammenfassung f¨ ur 1.1 Willkommen\nVorstellung, Python, Programmieraufgaben:\n▶Programmieren ist eine m¨ achtige Kompetenz\n▶Python ist toll\n▶Fragen im Forum stellen und beantworten\n▶RefCard drucken\n▶Wenn du lokal arbeiten willst: Python und VScode installieren\n▶Programmieraufgaben mit automatischer Bewertung\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.1 Willkommen TOC 11/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.2 Syntax TOC 12/ 145\nOperatoren, Kommentare\n5 + 8 # Kommentare (nach einer Raute) werden ignoriert\n## 13\n6/7 # Leerzeichen sind irrelevant (hier)\n## 0.8571428571428571\n12 * 3.4 # Dezimalzahlen mit einem Punkt angeben\n## 40.8\n3 ** 2 # Exponenten (nicht 3^2!)\n## 9\n19 // 3 # ganzzahlige Division\n## 6\n19 % 3 # Modulo (Rest nach ganzahliger Division)\n## 1\n'''\nDies ist ein Kommentar\n¨ uber mehrere Zeilen. ->Gut zum Dokumentieren von Code :)\n'''\nPython MOOC - 1.2 Syntax TOC 13/ 145\nObjekte, Ausgaben auf der Konsole (shell / terminal)\nObjekt erstellen mit =Zeichen:\nx = \"Hallo, python Welt!\"\nx\n## 'Hallo, python Welt!'\nZeichenketten sind erstellbar mit \"und ’. In den meisten Umst¨ anden (z.B. VS Code, CodeOcean), braucht es einen\nexpliziten Aufruf, um etwas in der Konsole anzuzeigen:\nprint(x)\n## Hallo, python Welt!",
    "print braucht man nicht in jupyter notebooks, bei zeilenweiser\nAusf¨ uhrung und in diesen Folien (erstellt mit Rnw =\n + LATEX). Wenn du in VScode Befehle zeilenweise ausf¨ uhrst ( >>> in console),\nkannst du mit quit() wieder in den normalen Modus wechseln. Python MOOC - 1.2 Syntax TOC 14/ 145\nprint\nprint(\"Ich schreibe: \", x)\n## Ich schreibe: Hallo, python Welt! print konkateniert verschiedene Eingaben, getrennt durch sep\n(default \" \")und abgeschlossen mit end (default \"\\n\")\na = 5\nprint(\"a ist:\", a, \"gut\", sep=\"0\", end=\" \\n\\n\\n\")\nprint(\"a ist immer noch:\", a)\n## a ist:050gut\n##\n## a ist immer noch: 5\nprint(\"Berlin\", end = \"#\")\nprint(\"Potsdam\")\n## Berlin#Potsdam\nPython MOOC - 1.2 Syntax TOC 15/ 145\nH¨ aufige Fehler bei Objektnamen\na = 42\nGroß-/Kleinschreibung beachten:\nA + 88\n## NameError: name ’A’ is not defined\nObjektnamen d¨ urfen nicht mit Zahlen beginnen:\n12b = 67 / 5\n## SyntaxError: invalid decimal literal\nSchl¨ usselw¨ orter d¨ urfen nicht als Objektnamen verwendet werden:\nclass = 4\n## SyntaxError: invalid syntax\nAusf¨ uhrliche Liste h¨ aufiger Fehler, Liste der reservierten Keywords\nSyntaxError: oft Klammern oder Doppelpunkte vergessen (in Schleifen)\nObjektnamen sollten kurz und informativ sein,\nz.B. anzahl teilnehmer oder video dauer\nPython MOOC - 1.2 Syntax TOC 16/ 145\nObjektmethoden I\neine_liste = [42, 77, -5, 6]\neine_liste\n## [42, 77, -5, 6]\neine_liste.append(111) # Methode f¨ ur Listenobjekte\nDas Objekt wird ver¨ andert, ohne es neu zuzuweisen\n(wenn es ver¨ anderbar ist, siehe Lektion 2.1 Objekttypen). eine_liste\n## [42, 77, -5, 6, 111]\nPython MOOC - 1.2 Syntax TOC 17/ 145\nObjektmethoden II\nWenn eine Methode ein Objekt zur¨ uckgibt, k¨ onnen Methoden verkn¨ upft\nwerden (chaining):\nsatz = \"Eine normale Zeichenkette\"\nsatz.count(\"e\") # z¨ ahlt nur kleine e\n## 6\nsatz.lower() # macht alles klein\n## 'eine normale zeichenkette'\nsatz.lower().count(\"e\") # z¨ ahlt alle e\n## 7\nPython MOOC - 1.2 Syntax TOC 18/ 145\ninteraktive Nutzereingabe\nnutzer_eingabe = input()\nprint(\"Die Eingabe war:\", nutzer_eingabe)\nnutzer_eingabe = input(\"Bitte etwas eingeben: \")\nDie Ausgabe von input ist immer eine Zeichenkette (string), auch\nwenn eine Zahl eingegeben wird. Python MOOC - 1.2 Syntax TOC 19/ 145\nFunktionen aus Modulen\nGrundlegende Befehle wie print ,+,input , etc sind immer\nverf¨ ugbar. Funktionen wie sqrt sind in einem eigenen Paket (Modul). Diese m¨ ussen zuerst geladen werden:\nimport math\nmath.sqrt(700)\n## 26.457513110645905\nWeitere Methoden in Lektion 1.5 Module importieren\nPython MOOC - 1.2 Syntax TOC 20/ 145\nZeilen einer Textdatei lesen\nfname = \"textDatei.txt\"\nwith open(fname) as f:\ninhalt = f.read() # .splitlines()\nprint(inhalt)\n## Dies ist ein kleines Beispiel einer Textdatei\n## um das Einlesen von Zeilen in Python zu demonstrieren. ## F¨ ur echte Daten das Paket `pandas` verwenden!",
    "open(\"textDatei.txt\") ¨ offnet die Datei im Lesemodus\nwith garantiert, dass die Datei am Ende geschlossen wird (besonders\nim Falle eines Fehlers)\nDie Zeile nach with muss einger¨ uckt sein\ninhalt.splitlines() gibt eine Liste mit einer Textzeile pro\nListenelement aus\nPython MOOC - 1.2 Syntax TOC 21/ 145\nk¨ urzere Zuweisungen\na = 17\na = a + 8\na\n## 25\na = 17\na += 8\na\n## 25\nIn der DataScience als schlecht lesbar angesehen und nicht sehr\nempfohlen, wird aber besonders in Schleifen durchaus verwendet. a *= a+2 # a = a*(a+2)\nPython MOOC - 1.2 Syntax TOC 22/ 145\nZusammenfassung f¨ ur 1.2 Syntax\nSyntax, Objekte, Operatoren, Funktionen:\n▶+,-,*,/,**,//,%\n▶obj = \"string\" # Kommentar ;\n\"\"\"mehrzeiliger Kommentar\"\"\"\n▶print(\"Zeichen\", 42, obj, sep=\" \", end=\" \\n\")\n▶obj.method() ;string.lower().count(\"p\")\n▶nutzer_eingabe = input()\n▶import modul ;modul.funktion(x)\n▶with open(\"datei.txt\") as f: inhalt = f.read()\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.2 Syntax TOC 23/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.3 Datentypen TOC 24/ 145\nDatentypen\nWir haben schon drei Sorten von Daten gesehen: ganze Zahlen,\nKommazahlen und Zeichenketten. type(5)\n## <class 'int'>\ntype(5.67)\n## <class 'float'>\ntype(\"Zeichen\")\n## <class 'str'>\nprint(7 >4, 7 <4)\n## True False\ntype(7 >4)\n## <class 'bool'>\ntype(2+3j) # Komplexer Teil mit j statt mit i\n## <class 'complex'>\nPython MOOC - 1.3 Datentypen TOC 25/ 145\nDatentyp pr¨ ufen\nisinstance(7.5, int) # Klassenzugeh¨ origkeit pr¨ ufen\n## False\nisinstance(\"Hello\", (float, int, str) ) # einer von den 3\n## True\nobj = \"Zeichenkette\"\nprint(\"Typ ist: \", type(obj) )\n## Typ ist: <class 'str'>\nPython MOOC - 1.3 Datentypen TOC 26/ 145\nDatentyp ¨ andern (konvertieren)\nint(\"48\")\n## 48\nfloat(\"48\")\n## 48.0\nint(\"drei\") # Fehler falls nicht konvertierbar\n## ValueError: invalid literal for int() with base 10:\n’drei’\ntype(float(\"25\"))\n## <class 'float'>\nPython MOOC - 1.3 Datentypen TOC 27/ 145\nTypenkonvertierung Demo\n# Coding demo:\nf = float(input( 'Temperatur in °Fahrenheit eingeben: '))\nc = (f-32) / 1.8\nprint(\"Temperatur in °Celcius:\", round(c, 1))\nPython MOOC - 1.3 Datentypen TOC 28/ 145\nZusammenfassung f¨ ur 1.3 Datentypen\nDatentypen ermitteln:\n▶type(objekt)\n▶int(etwas daskonvertiert werden kann)\n▶isinstance(objekt, int)\n▶isinstance(objekt, (float, int, str) )\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.3 Datentypen TOC 29/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.4 Funktionen schreiben TOC 30/ 145\nFunktionssyntax I\ndef willkommen(name, zeit=\"morgen\"):\nmsg = \"Hallo, \" + name + \". Guten \" + zeit + \"!\"\nreturn msg\nwillkommen(name= 'Bob ', zeit= 'Abend ')\n## 'Hallo, Bob. Guten Abend!'\nwillkommen(name= 'Berry ')# mit dem Standardfall (morgen)\n## 'Hallo, Berry. Guten morgen!'\n▶Doppelpunkt :notwendig, danach einr¨ ucken\n▶mit Leerzeichen oder Tabstop, Hauptsache einheitlich\n▶Ohne explizites return gibt eine Funktion None zur¨ uck\n▶return beendet den Funktionsaufruf\n▶name & zeit sind Parameter, ”Berry” & ”Abend” sind Argumente\n▶Syntax: parameter=argument\nPython MOOC - 1.4 Funktionen schreiben TOC 31/ 145\nFunktionssyntax II\n▶Parameternamen k¨ onnen beim Aufruf weggelassen werden, sofern\ndie Argumente in der richtigen Reihenfolge gegeben werden:\nwillkommen(\"Lydia\", \"Mittag\")\n## 'Hallo, Lydia. Guten Mittag!'\n▶print() zeigt eine Ausgabe in der Konsole an. ▶return beschreibt den Funktionsr¨ uckgabewert,\n▶der danach zugewiesen werden kann\n▶und mit dem weitergearbeitet werden kann. ▶In der Realit¨ at eigentlich immer return verwenden\n▶Das Wort ”ausgeben” wird f¨ ur ”zur¨ uckgeben” und ”anzeigen”\nverwendet. In den Programmieraufgeben ist meist return oder\nprint vorgegeben. ▶IndentationError: Zu wenig oder zu viel Einr¨ uckung\nPython MOOC - 1.4 Funktionen schreiben TOC 32/ 145\nBeispiel einer Funktion\nimport math\ndef kugel_volumen_berechnen(radius, nachkommastellen=3):\nvolumen = (4/3) * math.pi * radius**3\ngerundet = round(volumen, nachkommastellen)\nreturn gerundet\nkugel_volumen_berechnen(2)\n## 33.51\nkugel_volumen_berechnen(2, 5)\n## 33.51032\nWas ist hier gut? ▶Funktionsname ist ein Verb\n▶Parameternamen erkl¨ aren sich selbst\n▶gute Objektnamen innerhalb der Funktion\n▶math außerhalb der Funktion importiert\nPython MOOC - 1.4 Funktionen schreiben TOC 33/ 145\nScoping (G¨ ultigkeitsbereich) - welche Objekte werden gefunden I\nLokale Objekte in einer Funktion haben Vorrang:\nimport math\ndef tische_zaehlen(n):\ntische = n/6\naufgerundet = math.ceil(tische)\nreturn aufgerundet\nanzahl_gaeste = 78\ntische_zaehlen(anzahl_gaeste)\n## 13\ntische = 4000\ntische_zaehlen(22) # Funktion verwendet internes Objekt\n## 4\naufgerundet\n## NameError: name ’aufgerundet’ is not defined\nLokale objekte (innerhalb einer Funktion) sind tempor¨ ar und nach der\nAusf¨ uhrung der Funktion nicht global verf¨ ugbar\nPython MOOC - 1.4 Funktionen schreiben TOC 34/ 145\nScoping (G¨ ultigkeitsbereich) - welche Objekte werden gefunden II\nGlobale Objekte sind in einer Funktion verf¨ ugbar:\ndef anzahl_stuehle(n):\nreturn anzahl_gaeste\nanzahl_stuehle(17)\n## 78\nMit globalen Objekten innerhalb einer Funktion nur arbeiten, wenn man\nweiß, was man tut!",
    "Python MOOC - 1.4 Funktionen schreiben TOC 35/ 145\nZusammenfassung f¨ ur 1.4 Funktionen schreiben\nwiederverwendbare Codebl¨ ocke:\n▶Funktionssyntax:\ndef funktionsname(parameter, mit_default=\"argument\"):\nausgabe = parameter + 5\nreturn ausgabe\nparameter + 8 # code nach return nie ausgef¨ uhrt\n▶Einr¨ uckung einheitlich\n▶print vs return beachten\n▶lokale Objekte existieren nur innerhalb der Funktion\n▶globale Objekte nicht in einer Funktion verwenden\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.4 Funktionen schreiben TOC 36/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.5 Module importieren TOC 37/ 145\nEingebaute Pakete (Module)\nPython kommt mit einigen Modulen vorinstalliert (Standardbibliothek). Diese m¨ ussen nicht installiert werden (Liste). Zur verwendung in einem Skript m¨ ussen sie aber geladen werden. import math\nradius = float(input( 'Bitte Radius eingeben: '))\nprint(\"Der Umfang ist \", 2 * math.pi * radius)\nGute Praxis beachten:\nfrom math import * # NICHT BENUTZEN! from math import sqrt, pi # schwer nachvollziehbar\nimport math # sauber, lesbar\nmath.pi # - >K¨ onigsweg\nimport math as m # etwas k¨ urzer\nm.pi # pandas - >pd\nPython MOOC - 1.5 Module importieren TOC 38/ 145\nExterne Module\nQuellePopul¨ are Pakete\n▶Data science: numpy ,pandas\n▶Machine learning: tensorflow ,pytorch\n▶Statistical analysis: scipy\n▶Web application: django\n▶Plotting: matplotlib ,seaborn\nModule von pypi.org (PYthonPackageIndex) installieren mit pip (bei\nPython inklusive). In Konsole / Terminal / Shell / bash / cmd:\npip install numpy # pip3 unter MacOS\npip list\nAuf dem Macbook mache ich das mit R:\ninstall.packages(\"reticulate\")\nreticulate::install_miniconda()\nreticulate::py_install(\"numpy\")\nImportError: Name falsch geschrieben? Python MOOC - 1.5 Module importieren TOC 39/ 145\nBeispiele f¨ ur Paketnutzungen\nZufallszahlen:\nimport random\nrandom.random() # float von 0 (inkl) bis 1 (exklusive)\nrandom.randint(1, 6) # int von 1 (inkl) bis 6 (inkl!!!)\nZ¨ ahlung:\nimport collections\nf = [ 'rot ', 'blau ', 'blau ', 'gelb ', 'blau ', 'rot ', 'lila ']\ncollections.Counter(f).most_common(3)\n## [('blau', 3), ('rot', 2), ('gelb', 1)]\nMehrere Module k¨ onnen in einer Zeile importiert werden:\nimport collections, statistics, random\nPython MOOC - 1.5 Module importieren TOC 40/ 145\nEinlesen (Ausf¨ uhren) von .py Dateien\nArbeitsverzeichnis (Pfad, Ordner), current working directory:\nimport os\nos.getcwd().replace(os.sep, '/ ')\n## 'C:/Dropbox/pymooc/folien'\nSiehe auch das Modul pathlib\nDort liegt meinskript.py mit anzahl = 25 . from meinskript import anzahl\nprint(anzahl+2)\n## 27\nBeachte: kein echter Dateiname (mit .py-Endung)!",
    "import meinskript\nmeinskript.anzahl\n## 25\nPython MOOC - 1.5 Module importieren TOC 41/ 145\nObjekte in .py-Dateien\nimport meinskript\nprint(\" \\n\".join(dir(meinskript))) # Objekte im Modul\n## __builtins__\n## __cached__\n## __doc__\n## __file__\n## __loader__\n## __name__\n## __package__\n## __spec__\n## anzahl\n## job\n## random\n## simuliere_job\nPython MOOC - 1.5 Module importieren TOC 42/ 145\nFunktionen in .py-Dateien\ntype(meinskript.simuliere_job)\n## <class 'function'>\nmeinskript.simuliere_job()\n## 'coder'\nmeinskript.simuliere_job()\n## 'arzt'\nimport inspect\nprint(inspect.getsource(meinskript.simuliere_job))\n## def simuliere_job():\n## jobs = [\"lehrer\",\"handwerker\",\"arzt\",\"coder\"]\n## return random.choice(jobs)\nWenn Argumente vorhanden sind:\ninspect.getfullargspec(meinskript.simuliere_job)\n## FullArgSpec(args=[], ... defaults=None ... Python MOOC - 1.5 Module importieren TOC 43/ 145\nZusammenfassung f¨ ur 1.5 Module importieren\nModule und Skripte importieren:\n▶import paket as pak ; pak.fun()\n▶from paket import fun ; fun()\n▶pip install externes paket in einer Konsole\n▶from lokale python datei import ein objekt\n▶inspect.getsource(eine function)\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.5 Module importieren TOC 44/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren1.1 Willkommen\n1.2 Syntax\n1.3 Datentypen\n1.4 Funktionen schreiben\n1.5 Module importieren\n1.6 Zeichenketten\nPython MOOC - 1.6 Zeichenketten TOC 45/ 145\nTeile von Zeichenketten ausw¨ ahlen (subsetting, indexing)\nk = \"Hallo, Welt!\"\nk[7] # 8. Buchstabe\n## 'W'\nPython indiziert ab 0! k[3:7] # 4. bis 7. (rechts\nexklusiv des 8.)\n## 'lo, '\nk[:6] # 1. bis 6. ## 'Hallo,'k[2:] # 3. bis letzte\n## 'llo, Welt!'\nk[-2] # vorletze\n## 't'\nk[-5:-2] # kombinierbar\n## 'Wel'\nk[5:-2] # gemischt geht\n## ', Wel'\nk[400]\n## IndexError: string index out of range\nk[3.5]\n## TypeError: string indices must be integers\nk[2] = 'K '# strings sind nicht ¨ anderbar (siehe 2.1)\n## TypeError: ’str’ object does not support item assignment\nPython MOOC - 1.6 Zeichenketten TOC 46/ 145\nOperatoren f¨ ur Zeichenketten\na = \"Hallo\"\nlen(a) # Anzahl Zeichen\n## 5\n\"Zeichen \" + \"Kette \" + a # zusammenf¨ ugen\n## 'Zeichen Kette Hallo'\n\"Zeichen \" + \"Kette \" + 77\n## TypeError: can only concatenate str (not \"int\") to str\n3 * a # wiederholen\n## 'HalloHalloHallo'\n3 / a\n## TypeError: unsupported operand type(s) for /: ’int’\nand ’str’\n\"lo\" in a # Pr¨ asenz pr¨ ufen\n## True\nPython MOOC - 1.6 Zeichenketten TOC 47/ 145\nZeichenketten aufteilen und zusammenf¨ uhren\nzk = \"Etwas Text und einige Worte\"\nzk.split() # Ausgabe: Liste.",
    "Standard: sep=\" \"\n## ['Etwas', 'Text', 'und', 'einige', 'Worte']\nzk# immutable: nicht ver¨ andert\n## 'Etwas Text und einige Worte'\nprint(\"Zeichenkette mit \\nZeilenumbruch\")\n## Zeichenkette mit\n## Zeilenumbruch\n\"Zeichenkette mit \\nZeilenumbruch\".split(\" \")\n## ['Zeichenkette', 'mit\\nZeilenumbruch']\n\"Zeichenkette mit \\nZeilenumbruch\".split()\n## ['Zeichenkette', 'mit', 'Zeilenumbruch']\n# sep Default ist jede Art von Leerzeichen, inkl. \\n\n\"_\".join([\"Liste\", \"mit\", \"Worten\"])\n## 'Liste_mit_Worten'\nPython MOOC - 1.6 Zeichenketten TOC 48/ 145\nZeichenketten mit Objektbezug: F-strings\nname=\"Berry\" ; anzahl=7\nf\"Ich bin {name }und habe {anzahl }Katzen.\"\n## 'Ich bin Berry und habe 7 Katzen.'\nf\"Ich bin {name }und habe {anzahl+4 }Katzen.\"\n## 'Ich bin Berry und habe 11 Katzen.'\nsiehe realpython.com\nPython MOOC - 1.6 Zeichenketten TOC 49/ 145\nZusammenfassung f¨ ur 1.6 Zeichenketten\nZeichenketten (strings) verarbeiten:\n▶string[position]\n▶len(string)\n▶+,*,in\n▶string.split() ,string.join()\n▶f\"string mit {Objekt }Referenz\"\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.6 Zeichenketten TOC 50/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren2.1 Objekttypen\n2.2 Listen\n2.3 Dictionaries\nPython MOOC - 2.1 Objekttypen TOC 51/ 145\nObjekte sind zum Teil ver¨ anderbar\nIn Python sind einige Objekte ver¨ anderbar (mutable):\neine_liste = [1,2,3]\neine_liste[1] = 99 # Listen sind ver¨ anderbar\neine_liste\n## [1, 99, 3]\neine_liste.append(77) # Methode = Funktion einer Klasse\neine_liste # ver¨ andert, ohne neue Zuweisung\n## [1, 99, 3, 77]\nZeichenketten sind nicht ver¨ anderbar:\nkette = \"Python ist toll\"\nkette[11] = \"T\"\n## TypeError: ’str’ object does not support item\nassignment\nPython MOOC - 2.1 Objekttypen TOC 52/ 145\nTupel\n▶¨Ahnlich wie Listen\n(4, 8, 4, -3.14)\n▶## (4, 8, 4, -3.14)\n(4, 8, \"drei\") # k¨ onnen gemischte Datentypen sein\n▶## (4, 8, 'drei')\n▶Oft als Subelement einer Liste genutzt\n▶um verschachtelte Klammern lesbar zu halten\n[(8,5), 9, 3, (4,7)]\n▶## [(8, 5), 9, 3, (4, 7)]\nPython MOOC - 2.1 Objekttypen TOC 53/ 145\nMehrfachzuweisung\nMehrfachzuweisung (multiple assignment) in einer Zeile\ndef eingaben_verdoppeln(x, y):\nreturn x*2, y*2\nergebnis = eingaben_verdoppeln(3, 4)\nergebnis # ein Tupel\n## (6, 8)\na, b = eingaben_verdoppeln(3, 4)\na# zwei separate Objekte\n## 6\nb\n## 8\nTauschen zweier Variablen:\na, b = b, a # rechte Seite wird zuerst ausgef¨ uhrt\nPython MOOC - 2.1 Objekttypen TOC 54/ 145\nMengen (sets)\ns1 = {1,2,3,4,5 }\ns2 = { 3,4,5,6,7,8 }\nOperatoren wie in mathematischen Mengen\ns1|s2 # Vereinigung\n## {1, 2, 3, 4, 5, 6, 7, 8}\ns1 & s2 # Schnitt\n## {3, 4, 5}\ns1 - s2 # Differenz: in s1, nicht in s2\n## {1, 2}\ns2 - s1\n## {8, 6, 7}\n# zeigt, dass die Eintr¨ age nicht geordnet sind\n{}# leeres Dictionary (nicht Menge!)\nset() # leere Menge\nPython MOOC - 2.1 Objekttypen TOC 55/ 145\nMengen haben einmalige Werte\nzahlen = [6, 3, 3, 4]\nWenn Listen in ein Set konvertiert werden, sind die Eintr¨ age (m¨ ogliche\nAuspr¨ agungen) nur einmal drin:\nset(zahlen)\n## {3, 4, 6}\nset([6, 3, \"3\", 4])\n## {3, 4, 6, '3'}\n\"3\" ist was anderes als 3\nNeue Werte k¨ onnen hinzugef¨ ugt werden:\ns1 = {1,2,3,4,5 }\ns1.add(7)\ns1\n## {1, 2, 3, 4, 5, 7}\nPython MOOC - 2.1 Objekttypen TOC 56/ 145\nObjekttypen (Collections) ¨Ubersicht\nTyp Beispiel ¨ anderbar geordnet indiziert Duplikate\nListe [1,3] ja ja ja ok\nTupel (1,2) nein ja ja ok\nMenge {1,4} ja * nein nein nein\nDict {”a”:7,\n”b”:6 }ja nein / ja seit\nPython 3.6mit\nSchl¨ usselnein **\n*: die Elemente m¨ ussen immutable sein\n**: die Schl¨ ussel m¨ ussen einmalig sein, Werte sind mehrfach erlaubt\nListe : verschiedene Daten\nTupel : gruppieren verwandter Daten\nMenge : schnelle ¨Uberpr¨ ufung, ob ein Wert enthalten ist\nDictonary : schnelles Abrufen anhand von Schl¨ usselnamen\nPython MOOC - 2.1 Objekttypen TOC 57/ 145\nZusammenfassung f¨ ur 2.1 Objekttypen\n¨Uberblick Objekte, Tupel und Mengen:\n▶Liste, Tupel, Menge, Dictionary\n▶ver¨ anderbar, geordnet\n▶Mengenoperationen\nMelde unklare Aufgaben im Forum.",
    "Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.1 Objekttypen TOC 58/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren2.1 Objekttypen\n2.2 Listen\n2.3 Dictionaries\nPython MOOC - 2.2 Listen TOC 59/ 145\nListe: Erstellung + Teilmengenbildung I\nliste = [7, -4, 9, 1, 2, 3, 9, 5]\nlen(liste)\n## 8\nliste[0] # erstes Element\n## 7\nliste[1] # zweites Element\n## -4\nliste[5] # Element 6\n## 3\nliste[2:5] # Elemente 3,4,5\n## [9, 1, 2]\nBereiche sind exklusiv am rechten Ende\n:ist außerhalb der Teilmengenbildung kein Operator\nleere_liste = []\nPython MOOC - 2.2 Listen TOC 60/ 145\nListe: Erstellung + Teilmengenbildung II\nliste\n## [7, -4, 9, 1, 2, 3, 9, 5]\nliste[4:] # Teilung: f¨ unftes bis letztes Element\n## [2, 3, 9, 5]\nliste[:6] # 1. - 6.",
    "## [7, -4, 9, 1, 2, 3]\nliste[-2] # vorletztes Element\n## 9\nliste[2:-3] # hier ¨ aquivalent zu liste [2:5]\n## [9, 1, 2]\nliste[2] = \"neuerWert\" # ¨ uberschreibe drittes Element\nliste\n## [7, -4, 'neuerWert', 1, 2, 3, 9, 5]\nverschiedene Datentypen m¨ oglich\nPython MOOC - 2.2 Listen TOC 61/ 145\nListenelement an Index entfernen\nzahlen = [1,2,3,4,5,6,7]\nende = zahlen.pop() # letztes Element entfernen + ausgeben\nende\n## 7\nzahlen # ver¨ andert, ohne neue Zuweisung\n## [1, 2, 3, 4, 5, 6]\nzahlen.pop(3) # angegebenes Element entfernen (+ ausgeben)\nzahlen\n## 4\n## [1, 2, 3, 5, 6]\ndel(zahlen[2]) # Element an Index entfernen\nzahlen\n## [1, 2, 5, 6]\ndel funktioniert auch ohne Klammern\nPython MOOC - 2.2 Listen TOC 62/ 145\nListenelement nach Wert entfernen\nwerte = [1,2,3,4,5,6,7,4]\n4 in werte # pr¨ uft ob in der Liste, gibt boolean zur¨ uck\n## True\n9 not in werte # pr¨ uft ob nicht in der Liste\n## True\nwerte.index(4) # Index vom ersten Auftreten von 4\n## 3\nwerte.remove(4) # erste Instanz von 4 entfernen\nwerte\n## [1, 2, 3, 5, 6, 7, 4]\nPython MOOC - 2.2 Listen TOC 63/ 145\nElemente hinzuf¨ ugen\nwerte.append(66) # am Ende anf¨ ugen\nwerte\n## [1, 2, 3, 5, 6, 7, 4, 66]\nwerte.insert(3, \"neu\") # an Position einf¨ ugen\nwerte\n## [1, 2, 3, 'neu', 5, 6, 7, 4, 66]\ninsert verschiebt Elemente nach Eingef¨ ugtem nach hinten\nzahlen + werte[:6]\n## [1, 2, 5, 6, 1, 2, 3, 'neu', 5, 6]\nPython MOOC - 2.2 Listen TOC 64/ 145\nListensortierung\nj_liste = [7, -4, 9, 1, 2, 3]\nj_liste.reverse()\nj_liste\n## [3, 2, 1, 9, -4, 7]\nj_liste.sort()\nj_liste\n## [-4, 1, 2, 3, 7, 9]\nj_liste.sort(reverse=True)\nj_liste\n## [9, 7, 3, 2, 1, -4]\nk_liste = [7, -4, \"9\", 1, 2, 3]\nk_liste.sort()\n## TypeError: ’<’ not supported between instances of\n’str’ and ’int’\nPython MOOC - 2.2 Listen TOC 65/ 145\nListenverschachtelung + verl¨ angerung\nm_liste = [1, 2, 3, [31,32,33], 4] # Verschachtelung OK\nch_liste = [\"W¨ orter\",\"mit\",\"vielen\",\"Buchstaben\"]\nch_liste[2][5] # fortlaufend indiziert: Wort 3, Buchst.",
    "6\n## 'n'\nlx = [1, 2, 3, 4]\nly = [5, 6]\nlz = [7, 8, 9]\nlx.extend(ly) # ¨ andert lx\nlx\n## [1, 2, 3, 4, 5, 6]\nlx + ly # ¨ andert lx nicht, daf¨ ur: lx = lx + ly\n## [1, 2, 3, 4, 5, 6, 5, 6]\nlz * 2\n## [7, 8, 9, 7, 8, 9]\nPython MOOC - 2.2 Listen TOC 66/ 145\nListen zusammenf¨ uhren\nwoerter = [\"mehrere\", \"W¨ orter\"]\n\"\\n\".join(woerter)\n## 'mehrere\\nW¨ orter'\nprint(\" \\n\".join(woerter))\n## mehrere\n## W¨ orter\ngemischt = [99, \"Luftballons\"]\nprint(\" \\n\".join(gemischt))\n## TypeError: sequence item 0: expected str instance,\nint found\n# Stern (splat) Operator entpackt Liste\nprint(*gemischt, sep=\" \\n\")\n## 99\n## Luftballons\nPython MOOC - 2.2 Listen TOC 67/ 145\nListen umkehren (Aufgabe)\nKorrigiere den Fehler im folgenden Code. Warum tritt er auf? liste = [\"a1\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"c1\", \"d1\"]\nliste = liste.reverse()\nprint(liste[2]) # sollte \"b5\" sein\n## TypeError: ’NoneType’ object is not subscriptable\nPython MOOC - 2.2 Listen TOC 68/ 145\nListen umkehren (L¨ osung)\nDie Listenmethode ’reverse’ ¨ andert die Liste selbst, da das ein\nver¨ anderbares Objekt ist. Sie wird f¨ ur den Seiteneffekt aufgerufen, daher ”gibt sie nichts zur¨ uck”. Sie gibt None zur¨ uck, was ’liste’ ¨ uberschrieben hat. liste = [\"a1\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"c1\", \"d1\"]\nliste.reverse()\nprint(liste[2])\n## b5\nPython MOOC - 2.2 Listen TOC 69/ 145\nListe kopieren f¨ ur eine unabh¨ angige Instanz\nliste = [1,2,3,4,5,6]\nandere_liste = liste\nandere_liste\n## [1, 2, 3, 4, 5, 6]\nliste.append(9)\nandere_liste # hat sich auch ver¨ andert! ## [1, 2, 3, 4, 5, 6, 9]\nReferenziert dasselbe Objekt im Arbeitsspeicher (Pointer, id(objekt) )\ndritte_liste = liste.copy() # unabh¨ angige Kopie\ndritte_liste\n## [1, 2, 3, 4, 5, 6, 9]\nliste[1] = 99\ndritte_liste # wurde nicht ver¨ andert\n## [1, 2, 3, 4, 5, 6, 9]\nPython MOOC - 2.2 Listen TOC 70/ 145\nG¨ ultigkeitsbereich (Scope) in Funktionen (Quelle)\n# Liste in einer Funktion k¨ urzen\ndef maxOhne5(ll):\nll.remove(5)\nreturn max(ll)\n# ver¨ andert globale Liste (ver¨ anderbares Objekt)\nliste_a = [1,2,3,4,5]\nprint(liste_a) # [1, 2, 3, 4, 5]\nprint(maxOhne5(liste_a)) # 4\nprint(liste_a) # [1, 2, 3, 4] <-- ver¨ andert!",
    "def maxOhne5(ll):\nll = ll.copy() # lokale Kopie mit andere ID\nll.remove(5)\nreturn max(ll)\nliste_b = [1,2,3,4,5]\nprint(liste_b) # [1, 2, 3, 4, 5]\nprint(maxOhne5(liste_b)) # 4\nprint(liste_b) # [1, 2, 3, 4, 5]\nPython MOOC - 2.2 Listen TOC 71/ 145\nZusammenfassung f¨ ur 2.2 Listen\nListen sind die Basis von allem:\n▶Indexierung (Submengen ausw¨ ahlen) ab 0, (slicing)\n▶gemischte Datentypen sind m¨ oglich\n▶len(liste) ,liste.pop(index) ,in,not in\n▶liste.index(wert) ,liste.remove(wert)\n▶liste.append(wert) ,liste.insert(index, wert)\n▶listeA + listeB ,listeA.extend(listeB)\n▶liste.reverse() ,liste.sort()\n▶liste.copy()\n▶ver¨ anderbare Objekte innerhalb einer Funktion ¨ andern, ¨ andert sie\nglobal\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.2 Listen TOC 72/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren2.1 Objekttypen\n2.2 Listen\n2.3 Dictionaries\nPython MOOC - 2.3 Dictionaries TOC 73/ 145\nDictionaries\n▶speichert Daten in Form Schl¨ ussel:Wert\n▶optimiert, Werte schnell abzurufen, wenn der Schl¨ ussel bekannt ist\n▶Schl¨ ussel sind einmalig, Datentyp der Werte ist egal\nNutzungsbeispiele:\n▶Produktkatalog\n▶Patienten IDs mit weiteren Informationen (kann Liste oder\nUnter-Dictionary sein)\n▶HTTP-Statuscodes\n▶Kontaktliste (Telefonbuch)\n▶Warenkorb in Onlineshops\nPython MOOC - 2.3 Dictionaries TOC 74/ 145\nDictionaries\ndozent = { 'Name ': \"Berry\",\n'Alter ': 32 }\nlen(dozent)\n## 2\ndozent[ 'Name ']# Zugriff auf einen Eintrag\n## 'Berry'\ndozent[ 'Alter '] = 33 # Eintrag ¨ uberschreiben\ndozent\n## {'Name': 'Berry', 'Alter': 33}\ndozent[ 'Studis '] = 42 # Eintrag hinzuf¨ ugen\ndozent\n## {'Name': 'Berry', 'Alter': 33, 'Studis': 42}\nPython MOOC - 2.3 Dictionaries TOC 75/ 145\nNamenskonvention\nIch benutze ’ Apostrophen in Dictionaries, da sie in f-strings mit ”\nAnf¨ uhrungszeichen benutzt werden k¨ onnen. Doppelte und einfache Anf¨ uhrungszeichen k¨ onnen im F-string nicht\ngemischt werden. f\"Erstelle einen String mit {3+4}Berechnungen.\"\n## 'Erstelle einen String mit 7 Berechnungen.'\nf\"Hi {dozent[ 'Name ']}, du bist {dozent[ 'Alter ']}Jahre\nalt.\"\n## 'Hi Berry, du bist 33 Jahre alt.'\nSeit Python 3.12 (2023-10) ist das doch m¨ oglich.",
    "Python MOOC - 2.3 Dictionaries TOC 76/ 145\nZugriff auf Dictionaries\nfehlersichere Auswahl eines Schl¨ ussels:\ndozent.get( 'Name ', \"Wert falls Schl¨ ussel fehlt\")\n## 'Berry'\ndozent.get( 'NAME ', \"Wert falls Schl¨ ussel fehlt\")\n## 'Wert falls Schl¨ ussel fehlt'\ndozent.keys() # Quasi eine Liste als Ausgabe\n## dict_keys(['Name', 'Alter', 'Studis'])\ndozent.values() # dozent.items() zum Iterieren\n## dict_values(['Berry', 33, 42])\n\"Alter\" in dozent.keys()\n## True\n\"Alter\" in dozent # k¨ urzer und schneller :)\n## True\nPython MOOC - 2.3 Dictionaries TOC 77/ 145\nElemente aus einem Dictionary entfernen\ndozent = { 'Name ':\"Berry\", 'Alter ':32, 'Studis ':42, 'z ':0}\ndel(dozent[ 'Alter '])# entfernt kompletten Eintrag\ndozent\n## {'Name': 'Berry', 'Studis': 42, 'z': 0}\nstudis = dozent.pop( 'Studis ')\nstudis\n## 42\ndozent\n## {'Name': 'Berry', 'z': 0}\ndozent.pop( 'Alter ')# Schl¨ ussel nicht mehr da\n## KeyError: ’Alter’\ndozent.pop( 'Alter ', None) # gibt None zur¨ uck\ndozent.clear() # Alle Eintr¨ age entfernen\ndozent\n## {}\nPython MOOC - 2.3 Dictionaries TOC 78/ 145\nDictionary: Zeiger (memory pointer) und Kopien\ndict1 = { 'a ': 1, 'b ': 2, 'c ': 3}\ndict2 = dict1 # dict2 ist nur ein Zeiger auf dict1\ndict3 = dict1.copy() # unabh¨ angige Kopie\nWenn man dict1 ver¨ andert, ¨ andert sich auch dict2 . (Das gilt f¨ ur alle ver¨ anderbaren Objekte). dict1[ 'c '] = 333\ndict2\n## {'a': 1, 'b': 2, 'c': 333}\ndict3\n## {'a': 1, 'b': 2, 'c': 3}\nPython MOOC - 2.3 Dictionaries TOC 79/ 145\nDictionaries aktualisieren\ndict1 = { 'a ': 1, 'b ': 2, 'c ': 3}\ndict2 = { 'a ': 11, 'd ': 4}\ndict1.update(dict2) # aktualisiert Werte oder f¨ ugt\nEintr¨ age hinzu\ndict1\n## {'a': 11, 'b': 2, 'c': 3, 'd': 4}\nPython MOOC - 2.3 Dictionaries TOC 80/ 145\nDictionary formatiert ausgeben\ndozent = { 'Name ': \"Berry\", 'Alter ': 32 }\nfor k, v in dozent.items():\nprint(\"Der Eintrag '\",k,\" 'hat den Wert: \",v, sep=\"\")\n## Der Eintrag 'Name' hat den Wert: Berry\n## Der Eintrag 'Alter' hat den Wert: 32\nN¨ achste Woche behandeln wir For-Schleifen :)\nPython MOOC - 2.3 Dictionaries TOC 81/ 145\nZusammenfassung f¨ ur 2.3 Dictionaries\ndictionaries (Schl¨ ussel-Wert Paare):\n▶dict = {’Schluessel’:\"Wert\" }\n▶dict[’Schluessel’]\n▶dict.get(’Schluessel’, \"Ersatz\")\n▶’Schl¨ ussel’ in dict\n▶dict.pop(’Schluessel’, \"Ersatz\") ,dict.clear()\n▶dict.copy()\n▶dictA.update(dictB)\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.3 Dictionaries TOC 82/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren3.1 Bedingte Codeausf¨ uhrung\n3.2 For- und While-Schleifen\n3.3 List comprehension\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 83/ 145\nVergleichende und logische Operatoren\nvergleichende Operatoren:\na == b # ist a gleich b? a != b # ungleich? a<b# kleiner als\na<= b # kleiner / gleich\na>b# gr¨ oßer als\na>= b # gr¨ oßer / gleich\nKommazahlen gerundet vergleichen:\nsumme = 5.1 + 1.1\nsumme == 6.2\n## False\nround(summe,8) == round(6.2, 8)\n## True\nimport math\nmath.isclose(summe, 6.2)\n## Truewert = 8\n7<wert <9# nice! ## True\n7<8\n\"9\"<\"A\"\n\"A\"<\"B\" # alle\n\"a\"<\"b\" # True\n\"A\"<\"a\"\n# zahl <GROß <klein\nlogische Operatoren:\nnot False # NICHT\n## True\nTrue and 6 >8# UND\n## False\n9>8 or False # ODER\n## True\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 84/ 145\nAchtung vor bit-Operatoren\n7>1 & 6 >1\n## False\n&ist ein Bit-Operator! (Nicht der UND-Operator wie in anderen Programmiersprachen)\n7>1 and 6 >1\n## True\nDas gilt auch f¨ ur das Zirkumflex (ˆ):\n2^3 # ist eigentlich 8\n## 1\n^ist ein bin¨ ares XOR (ausschließliches ODER)\nsiehe stackoverflow / Was macht der Zirkumflex-Operator\n&f¨ uhrt bitweise UND Operation auf Bits aus\nsiehe Wikipedia / Bitweise Operatoren\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 85/ 145\nBedingte Codeausf¨ uhrung: allgemeine Struktur\na = 10 ; b = 20\nif b >a:\nprint(\"b ist gr¨ oßer als a\")\n## b ist gr¨ oßer als a\na = 30 ; b = 30\nif b >a:\nprint(\"b ist gr¨ oßer als a\")\nelif a == b:\nprint(\"a und b sind gleich\")\n## a und b sind gleich\na = 100 ; b = 30\nif b >a:\nprint(\"b ist gr¨ oßer als a\")\nelif a == b:\nprint(\"a und b sind gleich\")\nelse:\nprint(\"a ist gr¨ oßer als b\")\n## a ist gr¨ oßer als b\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 86/ 145\nBedingte Codeausf¨ uhrung: Bedingungen kombinieren\na = 100 ; b = 30\nif a>b and (b==20 or b==30):\nprint(\"a ist gr¨ oßer und b ist 20 oder 30\")\n## a ist gr¨ oßer und b ist 20 oder 30\ncond = [True, False, True, True, True]\nall(cond) # alle wahr? ## False\nany(cond) # mindestens 1 wahr? ## True\nsum(cond) # Anzahl wahr\n## 4\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 87/ 145\nBedingte Codeausf¨ uhrung in einer Funktion: ¨Ubersicht\nF¨ ur eine Vierfeldertafel gibt es zwei Ans¨ atze\nmit return , verschachtelt, ohne elif :\nif cond1:\nif cond2: return \"tt\" # Zeilenumbr¨ uche vor return\nelse: return \"tF\" # aus Platzgr¨ unden\nif cond2: return \"Ft\" # weggelassen.",
    "In echt bitte\nelse: return \"FF\" # setzen f¨ ur den style guide\nmit print , eine Ebene, mit and +elif :\nif cond1 and cond2: print(\"tt\")\nelif cond1: print(\"tF\")\nelif cond2: print(\"Ft\")\nelse: print(\"FF\")\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 88/ 145\n\nBedingte Codeausf¨ uhrung - Mathe-Beispiel\nQuelle mit n=1 & inf als Grenzen:\n2x wenn x < 0.5\nf(x) = 1-2(x-0.5) wenn 0.5 <= x <= 1\n0 wenn x > 1\nx = -0.2\nif x>1:\ny = 0\nelif x >= 0.5:\ny = 2-2*x\nelse:\ny = 2*x\nprint(y)\n## -0.4\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 89/ 145\n\nBedingte Codeausf¨ uhrung - input-Beispiel\nusername = input( 'Gib deinen Nutzernamen ein: ')\npassword = input( 'Gib dein Passwort ein: ')\nGib Login erfolgreich aus f¨ ur den Nutzer admin mit Passwort\n123456, sonst Nutzername oder Passwort sind falsch\nif username == 'admin 'and password == '123456 ':\nprint( 'Login erfolgreich ')\nelse:\nprint( 'Nutzername oder Passwort sind falsch ')\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 90/ 145\nBedingte Codeausf¨ uhrung - Schaltjahr-Beispiel\nEin Schaltjahr ist ein Kalenderjahr, das einen zus¨ atzlichen Tag (29. Februar) enth¨ alt, um im Gleichschritt mit dem astrononomischen Jahr zu\nbleiben. Diese zus¨ atzlichen Tage treten in jedem Jahr auf, welches ein\nVielfaches von 4 ist, außer den Jahren, welche Vielfache von 100 sind, es\nsei denn, sie sind auch durch 400 teilbar. Finde heraus, ob ein Jahr ein Schaltjahr ist. Der Modulo-Operator ist %. Das Jahr sollte durch 4 teilbar sein und (nicht teilbar durch 100 oder\nteilbar durch 400)\njahr = int(input( 'Gib das Jahr ein: '))\nist_schalt = jahr%4==0 and jahr%100!=0 or jahr%400==0\nprint(ist_schalt)\nPython MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 91/ 145\nZusammenfassung f¨ ur 3.1 Bedingte Codeausf¨ uhrung\nLogik und Bedingte Codeausf¨ uhrung:\n▶Vergleichsoperatoren, min < value < max ,not,and,or\n▶&und ^sind bitweise Operatoren, nicht verwenden (außer das ist\nbeabsichtigt)\n▶Struktur bedingten Codes:\nif bedingung1:\nausdruck1\nelif bedingung2:\nausdruck2\nelse:\nausdruck3\n▶all,any,sum\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.1 Bedingte Codeausf¨ uhrung TOC 92/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren3.1 Bedingte Codeausf¨ uhrung\n3.2 For- und While-Schleifen\n3.3 List comprehension\nPython MOOC - 3.2 For- und While-Schleifen TOC 93/ 145\nSchleifen: Anweisungen wiederholen\nCode mehrfach ausf¨ uhren, jeweils mit einem anderen Wert\nNachfolgender Code hat viele Dopplungen:\nprint(list(range(1,4)))\nprint(list(range(1,5)))\nprint(list(range(1,9)))\nDas geht einfacher mit einer Schleife:\nfor ende in [4,5,9]:\nprint(list(range(1,ende)))\n## [1, 2, 3]\n## [1, 2, 3, 4]\n## [1, 2, 3, 4, 5, 6, 7, 8]\nPython MOOC - 3.2 For- und While-Schleifen TOC 94/ 145\nSchleifenstruktur\nfor variable in werte_liste :\nmach_etwas_mit(variable)\n# Doppelpunkt (:) wird ben¨ otigt\n# Einr¨ uckung ist wichtig\nwhile bedingung_erfuellt:\nfuehre_dinge_aus_die_ggf_die_bedingung_aendern()\nif diesmal_fertig:\ncontinue # springe zur n¨ achsten Iteration\nif ganz_fertig:\nbreak # brich die Schleife ab\nnur_ausfuehren_wenn_beide_FERTIGs_falsch_sind()\nKonvention f¨ ur eine nicht verwendete Indexvariable:\nfor _ in range(3):\nprint(\"kram\") # ->kram kram kram\nPython MOOC - 3.2 For- und While-Schleifen TOC 95/ 145\nfor-loop print-Beispiel 1\nfor zahl in (0,1,2,3):\nprint(zahl)\n## 0\n## 1\n## 2\n## 3\nfor zahl in range(4):\nprint(zahl)\n## 0\n## 1\n## 2\n## 3\nlist( range(8, 0, -2) ) # range Ende exklusiv\n## [8, 6, 4, 2]\nPython MOOC - 3.2 For- und While-Schleifen TOC 96/ 145\nfor-loop print-Beispiel 2\nZeige alle Objektnamen eines Moduls auf einer jeweils eigenen Zeile an:\nimport math # eingebautes Modul (Paket)\nfor f in dir(math):\nprint(f)\n## __doc__\n## ... # manuell ausgew¨ ahlte Ausgabe\n## __name__\n## __package__\n## acos\n## ceil\n## exp\n## factorial\n## gamma\n## inf\n## isnan\n## log10\n## pi\n## pow\n## sin\n## sqrt\nPython MOOC - 3.2 For- und While-Schleifen TOC 97/ 145\nfor-Schleife Maximum-Beispiel\nwerte = [923,790,447,617,534,93,895,60,21,\n962,992,302,435,902,795,482]\nStell dir vor, die Funktion max w¨ are nicht verf¨ ugbar. Bestimme den gr¨ oßten Wert mithilfe einer Schleife. maxi = 0\nfor w in werte:\nif w >maxi:\nmaxi = w\nprint(maxi)\n## 992\nPython MOOC - 3.2 For- und While-Schleifen TOC 98/ 145\nfor-loop Auswahl-Beispiel\nW¨ ahle alle geraden Zahlen aus einer Liste aus.",
    "zahlen = [468,976,701,269,841,7,917,698,689,526,307,791,718]\ngerade = [] # leere Liste initiieren\nfor n in zahlen:\nif n%2==0:\ngerade.append(n)\ngerade\n## [468, 976, 698, 526, 718]\nPython MOOC - 3.2 For- und While-Schleifen TOC 99/ 145\nMehrere Iteratoren\nMehrere Objekte in einer Codezeile (siehe 2.1 Objekttypen)\nfor a,b in [(1,11), (2,22), (3,33), (4,44)]:\nprint(\"a:\", a, \" b:\", b, \"- >Ergebnis:\", b-2*a)\n## a: 1 b: 11 -> Ergebnis: 9\n## a: 2 b: 22 -> Ergebnis: 18\n## a: 3 b: 33 -> Ergebnis: 27\n## a: 4 b: 44 -> Ergebnis: 36\nPython MOOC - 3.2 For- und While-Schleifen TOC 100/ 145\nwhile-loop print-Beispiel\nSo lange das geld ausreicht, Sachen kaufen (und Restbetrag anzeigen)\ngeld = 53\nwhile geld >10:\nprint(geld)\ngeld -= 10\nprint(\"finaler Wert:\", geld)\n## 53\n## 43\n## 33\n## 23\n## 13\n## finaler Wert: 3\nPython MOOC - 3.2 For- und While-Schleifen TOC 101/ 145\nwhile-loop input-Beispiel\nwiederholt eine Zahl per input abfragen, bis sie korrekt erraten wurde\nzahl = 0\nwhile zahl != 42 :\nzahl = input(\"Rate eine Zahl: \")\nzahl = int(zahl)\nif zahl==42:\nprint(\"Du hast die Antwort (auf alles) gefunden.\")\nelif zahl >42: # print(..., flush=True) in Rstudio\nprint(f\"Tut mir leid, {zahl }ist zu groß.\")\nelse:\nprint(f\"Tut mir leid, {zahl }ist zu klein.\")\n## Rate eine Zahl: 78\n## Tut mir leid, 78 ist zu groß. ## Rate eine Zahl: 31\n## Tut mir leid, 31 ist zu klein. ## Rate eine Zahl: 42\n## Du hast die Antwort (auf alles) gefunden.",
    "Python MOOC - 3.2 For- und While-Schleifen TOC 102/ 145\nwhile-loop input-Alternative\nwhile(True):\nzahl = input(\"Rate eine Zahl: \")\nzahl = int(zahl)\nif zahl==42:\nprint(\"Du hast die Antwort (auf alles) gefunden.\")\nbreak\nelif zahl >42:\nprint(f\"Tut mir leid, {zahl }ist zu groß.\")\nelse:\nprint(f\"Tut mir leid, {zahl }ist zu klein.\")\nwhile(True) beginnt eine Schleife, die manuell beendet werden muss\n(mittels break , in einer Funktion geht auch return )\nPython MOOC - 3.2 For- und While-Schleifen TOC 103/ 145\nSchleifensteuerung (control commands) Beispiele\nfor buchstabe in 'Python ':# strings sind iterierbar :)\nif buchstabe == 'h ':\ncontinue # ¨ uberspringe den Rest einer Ausf¨ uhrung\nprint(\"Aktuell: \" + buchstabe)\n## Aktuell: P\n## Aktuell: y\n## Aktuell: t\n## Aktuell: o\n## Aktuell: n\nfor buchstabe in 'Python ':\nif buchstabe == 'h ':\nbreak # die Schleife vollst¨ andig abbrechen\nprint(\"Aktuell: \" + buchstabe)\n## Aktuell: P\n## Aktuell: y\n## Aktuell: t\nPython MOOC - 3.2 For- und While-Schleifen TOC 104/ 145\nAbbildung (mapping)\nbuchstabenliste = [\"abcdef\", \"ab\", \"abc\"]\nbuchstabenlaenge = []\nfor b in buchstabenliste:\nbuchstabenlaenge.append(len(b))\nbuchstabenlaenge\n## [6, 2, 3]\nb_laenge = map(len, buchstabenliste)\nb_laenge\n## <map object at 0x000001E51057F760>\nlist(b_laenge)\n## [6, 2, 3]\nlist(map(len, buchstabenliste))\n# ist viel k¨ urzer als die Schleife oben :)\nPython MOOC - 3.2 For- und While-Schleifen TOC 105/ 145\nObjekte in Schleifen ¨ andern 1\nids = [\"a1\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\",\"c1\",\"d1\"]\n# Entferne Werte, die mit b starten\nfor v in ids:\nif v[0]==\"b\": ids.remove(v)\nids\n## ['a1', 'b2', 'b4', 'b6', 'c1', 'd1']\nWarum ist die H¨ alfte der b’s noch drin? Nach der zweiten Iteration ist ids a1, b2, b3, b4, b5, b6, c1, d1 ,\nweil ”b1” entfernt wurde. In der dritten Iteration wertet Python ’ids’\nwieder aus und gibt das dritte Element an v(”b3”). Dieses wird\nwieder entfernt, also verbleiben a1, b2, b4, b5, b6, c1, d1 .Das\nwiederholt sich, bis wir bei a1, b2, b4, b6, c1, d1 ankommen. Ein\nIndex hilft nicht: for i in range(len(ids)) gibt einen IndexError. Wie k¨ onnen wir korrekt in einer Schleife die Werte ausw¨ ahlen, die nicht\nmit b beginnen? Python MOOC - 3.2 For- und While-Schleifen TOC 106/ 145\nObjekte in Schleifen ¨ andern 2\nids = [\"a1\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\",\"c1\",\"d1\"]\nausgabe = []\nfor v in ids:\nif v[0]!=\"b\": ausgabe.append(v)\nprint(ausgabe)\n## ['a1', 'c1', 'd1']\nDas Iteratorobjekt in einer Schleife darf nicht ver¨ andert werden!",
    "Unerwartete Dinge: Iteration in Python\nEs gibt hier eine Alternative, die (scheinbar) ohne Schleife auskommt:\ndef beginnt_nicht_mit_b(x):\nreturn x[0]!=\"b\"\nlist(filter(beginnt_nicht_mit_b, ids))\n## ['a1', 'c1', 'd1']\nlist(filter(lambda x : x[0]!=\"b\", ids))\n## ['a1', 'c1', 'd1']\nPython MOOC - 3.2 For- und While-Schleifen TOC 107/ 145\nZusammenfassung f¨ ur 3.2 For- und While-Schleifen\nfor- und while-Schleifen :\n▶Schleifenstruktur:\nfor var in liste:\nausdruck(var)\n▶continue ,break\n▶for in range(n): f¨ ur ungenutzte Variable\n▶for x,y in [(x1,y1),(x2,y2)]:\n▶list(map(funktion, liste))\n▶list(filter(funktion, liste))\n▶Ver¨ andere nicht das Iterator-Objekt w¨ ahrend Iteration\n▶Im echten Leben: map/filter, list comprehension, pandas\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.2 For- und While-Schleifen TOC 108/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren3.1 Bedingte Codeausf¨ uhrung\n3.2 For- und While-Schleifen\n3.3 List comprehension\nPython MOOC - 3.3 List comprehension TOC 109/ 145\nList comprehension (Codel¨ ange verringern) - Beispiel 1\ndef tu_etwas_mit(x):\nreturn x + 5\neinige_zahlen = [6, 9, 17, -2, 24]\nergebnis = []\nfor zahl in einige_zahlen:\nneue_zahl = tu_etwas_mit(zahl)\nergebnis.append(neue_zahl)\nergebnis\n## [11, 14, 22, 3, 29]\nergebnis = [tu_etwas_mit(zahl) for zahl in einige_zahlen]\nergebnis\n## [11, 14, 22, 3, 29]\nlist(map(tu_etwas_mit, einige_zahlen))\n## [11, 14, 22, 3, 29]\nPython MOOC - 3.3 List comprehension TOC 110/ 145\nList comprehension (Codel¨ ange verringern) - Beispiel 2\nnamen = [\"Alex\",\"Berry\",\"Beth\",\"Chris\",\"Dave\"]\nmitB = []\nfor wort in namen:\nif wort[0] == \"B\":\nmitB.append(wort)\nmitB\n## ['Berry', 'Beth']\nmitB = [wort for wort in namen if wort[0] == \"B\"]\nmitB\n## ['Berry', 'Beth']\nPython MOOC - 3.3 List comprehension TOC 111/ 145\nDictionary comprehension funktioniert auch so\n# Gib die Buchstabenzahl jedes Wortes aus:\nnachricht = \"du steigerst dich\"\n{wort:len(wort) for wort in nachricht.split() }\n## {'du': 2, 'steigerst': 9, 'dich': 4}\n# Verdopple jeden Wert im Dictionary:\ndict1 = { 'a ': 1, 'b ': 2, 'c ': 3, 'd ': 4, 'e ': 5, 'f ':6}\ndoppel_dict1 = {k:v*2 for (k,v) in dict1.items() }\n# W¨ ahle alle geraden Eintr¨ age, die gr¨ oßer als 2 sind:\n{k:v for (k,v) in dict1.items() if v >2 and v%2==0 }\n## {'d': 4, 'f': 6}\n# Wandle von Grad Fahrenheit nach Celcius um:\ndF = { 't1 ': -30, 't2 ': -20, 't3 ': -10, 't4 ': 0}\ndC = {k:5/9*float(v-32) for (k,v) in dF.items() }\ndC = {k+\"C\":round(v) for (k,v) in dC.items() }\ndC\n## {'t1C': -34, 't2C': -29, 't3C': -23, 't4C': -18}\nPython MOOC - 3.3 List comprehension TOC 112/ 145\nList comprehension ¨Ubung\nK¨ urze alle drei Schleifen auf eine einzelne Codezeile.",
    "werte = [11,10,2,3,15,3,5,7,7,2,8,7,5,6,5,8,5,9,6,3,15,6,9]\nquadratsumme = 0\nfor v in werte:\nquadratsumme += v**2\nquadratsumme\n## 1351\nzahlen = [951,402,984,651,360,69,408,319,601,485,980,507,725,\n547,544,615,83,165,141,501,263,617,865,575,219,390,984,592,236,\n105,942,941,386,462,47,418,907,344]\ngerade_zahlen = []\nfor n in zahlen:\nif n%2==0: gerade_zahlen.append(n)\ngerade_zahlen\n## [402, 984, 360, 408, 980, 544, 390, 984, 592, 236, 942, 386, 462, 418, 344]\nimport random\nmax_exp = []\nfor i in range(50):\nmax_exp.append(random.expovariate(0.2))\nmax_exp = max(max_exp)\nmax_exp\n## 20.343037401675073\nPython MOOC - 3.3 List comprehension TOC 113/ 145\nList comprehension ¨Ubungsl¨ osungen\nwerte = [11,10,2,3,15,3,5,7,7,2,8,7,5,6,5,8,5,9,6,3,15,6,9]\nsum([v**2 for v in werte])\n## 1351\nzahlen = [951,402,984,651,360,69,408,319,601,485,980,507,725,\n547,544,615,83,165,141,501,263,617,865,575,219,390,984,592,236,\n105,942,941,386,462,47,418,907,344]\n[n for n in zahlen if n%2==0]\n## [402, 984, 360, 408, 980, 544, 390, 984, 592, 236, 942, 386, 462, 418, 344]\nimport random\nmax([random.expovariate(0.2) for _ in range(50)])\n## 19.221103122473906\nPython MOOC - 3.3 List comprehension TOC 114/ 145\nZusammenfassung f¨ ur 3.3 List comprehension\nSchleifen-code deutlich verk¨ urzen:\n▶Listen- und Dict comprehension\n▶[tuetwas mit(x) for x in liste if bedingung(x)]\n▶{k:tu etwas mit(v) for (k,v) in eine dict.items() }\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.3 List comprehension TOC 115/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren4.1 Fehlermanagement\n4.2 Eigene Klassen schreiben\n4.3 Unit Tests\nPython MOOC - 4.1 Fehlermanagement TOC 116/ 145\nFehlermanagement: try - except\nBei einem Fehler bricht die komplette Programmausf¨ uhrung ab. Beispiel: TypeError: falscher Datentyp f¨ ur Operator oder Funktion\nergebnis_einer_berechnung = \"2\"\n7 + ergebnis_einer_berechnung\n## TypeError: unsupported operand type(s) for +: ’int’\nand ’str’\nPython kann Code aber auch probeweise ausf¨ uhren, und im Fall eines\nFehlers was anderes machen als abbrechen.",
    "try:\n7 + ergebnis_einer_berechnung\nexcept TypeError:\nprint(\"Zeichenkette und Nummer gemischt\")\n## Zeichenkette und Nummer gemischt\nBeachte die Einr¨ uckung, wie mit allen Python Kontrollstrukturen\nPython MOOC - 4.1 Fehlermanagement TOC 117/ 145\ngenerisches except\ntry:\n7 + nichtExistierendesObjekt\nexcept TypeError:\nprint(\"Zeichenkette und Nummer gemischt\")\nexcept:\nprint(\"Ein Fehler ist aufgetreten\")\n## Ein Fehler ist aufgetreten\nPython MOOC - 4.1 Fehlermanagement TOC 118/ 145\nelse\ntry:\n7 + \"2\" # Code mit m¨ oglichen Fehlern\nexcept:\nprint(\"Code fehlgeschlagen\")\nelse:\nprint(\"Code erfolgreich ausgef¨ uhrt\")\n## Code fehlgeschlagen\nDer else Code wird ausgef¨ uhrt, wenn keine Fehler auftreten. K¨ onnte\nauch im try Teil sein, man sollte aber den potentiellen Fehler und den\nUmgang damit nah beieinander behalten. Fange nur erwartete Fehler ab\n(andere Fehler sollten weiterhin auftreten). else wird vor finally ausgef¨ uhrt (n¨ achste Folie). Python MOOC - 4.1 Fehlermanagement TOC 119/ 145\nfinally\ntry:\n7 + \"2\" # Code mit m¨ oglichen Fehlern\nexcept:\nprint(\"Code fehlgeschlagen\")\nfinally:\nprint(\"Programm fertig\")\n## Code fehlgeschlagen\n## Programm fertig\nCode in finally wird ausgef¨ uhrt, selbst wenn return / break / continue\naufgerufen wird oder ein anderer (nicht abgefangener) Fehler auftritt. Python MOOC - 4.1 Fehlermanagement TOC 120/ 145\ntraceback\ntraceback gibt aus, woher der Fehler kommt:\nimport traceback\ntry:\n7 + nichtExistierendesObjekt\nexcept:\nprint(\"Fehler aufgetreten:\",traceback.format_exc())\n## Fehler aufgetreten: Traceback (most recent call last):\n## File \"<string>\", line 2, in <module> ## NameError:\nname ’nichtExistierendesObjekt’ is not defined\ninformativer in echter Anwendung (Folienstruktur kann kein traceback).",
    "IDEs mit Debugger stellen oft tracebacks f¨ ur Fehler zur Verf¨ ugung\nPython MOOC - 4.1 Fehlermanagement TOC 121/ 145\nException Objekt\nFehler mit benutzerdefiniertem Pr¨ afix protokollieren\ndef addiere7_mit_print_statt_fehler(x):\ntry:\nreturn x + 7\nexcept Exception as e: # Fehlermeldung als Variable 'e '\nprint(\"Ein Fehler ist aufgetreten:\",e, sep=\" \\n\")\naddiere7_mit_print_statt_fehler(3)\n## 10\naddiere7_mit_print_statt_fehler(\"3\")\n## Ein Fehler ist aufgetreten:\n## can only concatenate str (not \"int\") to str\naddiere7_mit_print_statt_fehler(None)\n## Ein Fehler ist aufgetreten:\n## unsupported operand type(s) for +: 'NoneType' and 'int'\nPython MOOC - 4.1 Fehlermanagement TOC 122/ 145\nException info\ndef fehler_mit_ganzer_nachricht(x): # siehe auch\ntry: # sys.exc_info()\nx + 7\nexcept Exception as e:\nprint(f\"Ein {type(e).__name__ }ist passiert: \\n{e}\")\nfehler_mit_ganzer_nachricht(3)\nfehler_mit_ganzer_nachricht(None)\n## Ein TypeError ist passiert:\n## unsupported operand type(s) for +: 'NoneType' and 'int'\nfehler_mit_ganzer_nachricht(\"3\")\n## Ein TypeError ist passiert:\n## can only concatenate str (not \"int\") to str\nfehler_mit_ganzer_nachricht(dummyvar)\n## NameError: name ’dummyvar’ is not defined\nPython MOOC - 4.1 Fehlermanagement TOC 123/ 145\nZeitstempel\nNachrichten mit Zeitstempel, n¨ utzlich f¨ ur Logging (protokollieren)\nimport time\njetzt = time.strftime(\"%Y-%m-%d %H:%M UTC\", time.gmtime())\nprint(jetzt)\n## 2024-10-15 08:25 UTC\ndef fehler_mit_zeitstempel(x):\ntry:\nx + 7\nexcept:\nn = time.strftime(\"%Y-%m-%d %H:%M UTC\",time.gmtime())\nprint(\"Ein Fehler ist aufgetreten am:\", n)\nfehler_mit_zeitstempel(3)\nfehler_mit_zeitstempel(None)\n## Ein Fehler ist aufgetreten am: 2024-10-15 08:25 UTC\nPython MOOC - 4.1 Fehlermanagement TOC 124/ 145\nFehlermanagement Beispiel\npreis = None\nwhile not isinstance(preis, int):\ntry:\npreis = int(input(\"Gib einen Preis ein: \"))\nexcept ValueError:\nprint(\"Bitte gib eine g¨ ultige Nummer ein.\")\nprint(\"Die eingegebene Nummer war: \", preis)\nPython MOOC - 4.1 Fehlermanagement TOC 125/ 145\nZusammenfassung f¨ ur 4.1 Fehlermanagement\nExceptions abfangen und verwalten:\n▶Struktur\ntry:\ncode_mit_moeglichen_Fehlern\nexcept BestimmterError: # m¨ oglichst nur konkrete\nwas_jetzt_zu_tun_ist # Fehler abfangen! except Exception as e:\nmach_etwas_damit(e) # z.B. Logging\ntraceback.format_exc()\ntime.strftime(\"%Y-%m-%d %H:%M UTC\", time.gmtime())\nexcept: # falls Excpetion as e\nandere_Fehler_behandeln # nicht genutzt wurde\nelse:\nwas_zu_tun_ist_falls_BestimmterError_nicht_passiert\nfinally:\ntu_das_immer_am_Ende\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 4.1 Fehlermanagement TOC 126/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4.",
    "Programmieren4.1 Fehlermanagement\n4.2 Eigene Klassen schreiben\n4.3 Unit Tests\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 127/ 145\nBenutzerdefinierte Klassen\nEin paar Definitionen:\nObjekt : Sammlung von Daten (Variablen) und Methoden (Funktionen)\ndie auf Basis dieser Daten operieren. (Attribute + Verhalten)\nKlasse : Vorlage f¨ ur Objekte\nInstanz : spezifisches Objekt einer Klasse\nclass Person:\npass\nPython verbietet leere K¨ orper in Klassen. Das pass Statement dient als\nPlatzhalter f¨ ur Code\np1 = Person() # erstellt Instanz der Klasse Person\np1.name = \"Berry\" ; p1.alter = 32 # Attribute hinzuf¨ ugen\np1\n## <__main__.Person object at 0x000001EFD04EB9D0>\np1.__dict__ # Dictionary mit allen Attributen\n## {'name': 'Berry', 'alter': 32}\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 128/ 145\nBenutzerdefinierte Klasse definieren\nclass Person:\ndef __init__(self, name, alter):\nself.name = name\nself.alter = alter\nperson1 = Person( 'Berry ', 23) # konstruiert neue Person\nperson2 = Person( 'Christina ', 16)\nperson1.name\n## 'Berry'\ninit : spezielle Funktion die beim Erstellen des Objekts aufgerufen\nwird und die Attribute initialisiert. Sie wirkt wie ein Konstruktor. self: steht f¨ ur die Instanz der Klasse, mit der wir die Methode aufrufen. Es ist das erste Argument von Methoden wie init . Objekte person1 und person2 haben eigene Attribute (name, alter). Mit dem self Argument k¨ onnen die Methoden auf Attribute der\nspezifischen Instanz zugreifen. Python MOOC - 4.2 Eigene Klassen schreiben TOC 129/ 145\nMethoden einer benutzerdefinierten Klasse\neine Methode, die ¨ uberpr¨ uft ob eine Person Horrorfilme schauen darf:\nclass Person:\ndef __init__(self, name, alter):\nself.name = name\nself.alter = alter\ndef darf_horrorfilm_sehen(self): # diese Funktion\nif self.alter >= 18: # ist eine Methode\nreturn \"los gehts!\" # f¨ ur alle Objekte\nelse: # der Klasse ‘Person‘\nreturn \"sorry, zu jung\"\nperson1 = Person( 'Berry ', 23)\nperson1.darf_horrorfilm_sehen()\n## 'los gehts!'\nperson2 = Person( 'Christina ', 16)\nperson2.darf_horrorfilm_sehen()\n## 'sorry, zu jung'\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 130/ 145\n¨Ubung und Ressourcen\nWie kann man die Methode darf horrorfilm sehen vereinfachen,\nsodass sie True / False zur¨ uckgibt? def darf_horrorfilm_sehen(self):\nreturn self.alter >= 18\nWeiterf¨ uhrende Materialien:\nDr Philip Yip\nPython101\nPynative\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 131/ 145\nKlasse mit Eingabe¨ uberpr¨ ufung\nclass Patient:\ndef __init__(self, pid, geschlecht, BD):\nself.pid = pid\nself.geschlecht = geschlecht\nself.BD = BD\nif geschlecht not in [\"m\",\"w\",\"d\"]:\nraise ValueError(\"geschlecht muss m/w/d sein\")\ndef hat_bluthochdruck(self):\nreturn self.BD >130\nPatient(pid=\"Pat456\", geschlecht=\"Divers\", BD=120)\n## ValueError: geschlecht muss m/w/d sein\narmer_kerl = Patient(\"Pat123\", \"m\", 113)\narmer_kerl.BD = 150\nprint(\"jetzt behandeln:\", armer_kerl.hat_bluthochdruck())\n## jetzt behandeln: True\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 132/ 145\nKlassenvariablen, siehe z.B.",
    "ionos.de\nclass Student:\nanzahl = 0 # Klassenvariable\ndef __init__(self, name):\nself.name = name\nStudent.anzahl += 1 # bei jeder Erstellung + 1\ns1 = Student(\"Anna Lena\")\ns2 = Student(\"Christina\")\nStudent(\"Berry\")\nStudent.anzahl\n## 3\ns2.anzahl # Instanzvariable greift auf Klassenvariable zu\n## 3\ns2.anzahl = 1000\nStudent.anzahl # unabh¨ angig einer einzelnen Instanz\n## 3\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 133/ 145\nKlassen (Aufgabe + Teill¨ osung)\nHerons Formel ergibt die Fl¨ ache eines Dreiecks, wenn die L¨ ange aller drei\nSeiten bekannt ist. Eine Seite eines Dreiecks kann nicht l¨ anger sein als\ndie Summe der beiden Anderen. Schreibe Code, der die Fl¨ ache ausgibt -\noder ”Kein Dreieck”, wenn eine Seite zu lang ist. halbperimeter s= (a+b+c)/2 flaeche a= sqrt(s(s-a)(s-b)(s-c))\na = 10\nb = 4\nc = 5\nif a+b >c and a+c >b and b+c >a:\ns = (a+b+c)/2\nflaeche = (s*(s-a)*(s-b)*(s-c))**0.5 #**0.5 = sqrt\nf\"Flaeche des Dreiecks: {flaeche }\"\nelse:\n\"Kein Dreieck\"\nSchreibe eine Dreieck Klasse, die einen Fehler f¨ ur ung¨ ultige Dreiecke\nerzeugt und eine Fl¨ achenmethode hat. Python MOOC - 4.2 Eigene Klassen schreiben TOC 134/ 145\nKlassen Aufgaben (L¨ osung)\nclass Dreieck:\ndef __init__(self, a, b, c):\nself.a = a\nself.b = b\nself.c = c\nif not(a+b >c and a+c >b and b+c >a):\nraise ValueError( 'ung¨ ultig: zu lange Seite ')\ndef flaeche(self):\np = (self.a+self.b+self.c)/2\nflaeche = (p*(p-self.a)*(p-self.b)*(p-self.c))**0.5\nreturn flaeche\neck = Dreieck(a=3, b=4, c=5)\neck.__dict__ # Attribute ausgeben\n## {'a': 3, 'b': 4, 'c': 5}\neck.flaeche()\n## 6.0\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 135/ 145\nZusammenfassung f¨ ur 4.2 Eigene Klassen schreiben\nBenutzerdefinierte Klassen:\n▶generelle Struktur:\nclass MeineKlasse:\nclassVariable = \"wert\"\ndef __init__(self, args):\nself.args = args\nif not gueltig(args): raise SomeError(\"info\")\ndef eineMethode(self):\nreturn self.args\neineInstanz = MeineKlasse(\"werte\")\neineInstanz.eineMethode()\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 4.2 Eigene Klassen schreiben TOC 136/ 145\n1. Intro\n2. Objekte\n3. Schleifen\n4. Programmieren4.1 Fehlermanagement\n4.2 Eigene Klassen schreiben\n4.3 Unit Tests\nPython MOOC - 4.3 Unit Tests TOC 137/ 145\nWarum Testen? ▶Beim Programmieren k¨ onnen unbemerkt Fehler entstehen und sich\nim Code manifestieren. ▶Diese Fehler k¨ onnen zu unerwartetem Verhalten oder gar einem\nProgrammabbruch f¨ uhren. ▶Manuelles Ausprobieren aller m¨ oglichen F¨ alle wird zunehmend\naufw¨ andig und un¨ ubersichtlich.",
    "▶Daher: automatisiertes Testen\nPython MOOC - 4.3 Unit Tests TOC 138/ 145\nTestverfahren\n▶Statische Testverfahren (= ohne Codeausf¨ uhrung)\n▶Code-Reviews (durch Kolleg:innen, neuerdings durch KI)\n▶Quellcodeanalyse (z.B. PyLint)\ndef addiere(a, b):\nsumme = a + b\nreturn a + b\n## warning (W0612, unused-variable, addiere) Unused\nvariable ’summe’\n▶Dynamische Testverfahren (= mit Codeausf¨ uhrung)\n▶Unit Tests (z.B. mit PyUnit)\n▶Integration Tests (z.B. mit PyUnit)\n▶System Tests (z.B. Selenium f¨ ur Webanwendungen)\n▶Acceptance Tests (z.B. Selenium, Robot Framework)\nPython MOOC - 4.3 Unit Tests TOC 139/ 145\nBeispiel - ”zuletzt gesehen”\nEine Chatanwendung soll anzeigen, wann eine Person zuletzt online war. Die Anzeige soll in Minuten / Stunden / Tagen erfolgen. Skript onlinestatus.py mit folgender naiver Umsetzung:\ndef zuletzt_gesehen(sek):\nif sek == 0:\nreturn \"Online\"\nelif sek <60:\nreturn \"Zuletzt vor weniger als 1 Minute gesehen\"\nelif sek <60*60:\nreturn f\"Zuletzt vor {sek // 60 }Minuten gesehen\"\nelif sek <60*60*24:\nreturn f\"Zuletzt vor {sek // (60*60) }Stunden gesehen\"\nelse:\nreturn f\"Zuletzt vor {sek // (60*60*24) }Tagen gesehen\"\nPython MOOC - 4.3 Unit Tests TOC 140/ 145\nUnit Test – ”zuletzt gesehen”\nSkript test onlinestatus.py mit:\nimport unittest\nfrom onlinestatus import zuletzt_gesehen\nclass ZuletztGesehenTest(unittest.TestCase):\ndef test_online(self):\ntatsaechlich = zuletzt_gesehen(0)\nerwartet = \"Online\"\nself.assertEqual(tatsaechlich, erwartet)\nTest ausf¨ uhren - Option 1: Am Ende von test onlinestatus.py :\nif __name__ == \"__main__\": unittest.main()\nTest ausf¨ uhren - Option 2: leichter automatisierbar\npython -m unittest test_onlinestatus.py # Mac: python3\n## ------------------------------------------------------\n## Ran 1 test in 0.000s\n## OK\nPython MOOC - 4.3 Unit Tests TOC 141/ 145\nMehr Tests! import unittest\nfrom onlinestatus import zuletzt_gesehen\nclass ZuletztGesehenTest(unittest.TestCase):\ndef test_online(self):\nself.assertEqual(zuletzt_gesehen(0), \"Online\")\ndef test_eine_sekunde(self):\nself.assertEqual(zuletzt_gesehen(1),\n\"Zuletzt vor weniger als 1 Minute gesehen\")\ndef test_weniger_als_eine_minute(self):\nself.assertEqual(zuletzt_gesehen(59),\n\"Zuletzt vor weniger als 1 Minute gesehen\")\ndef test_eine_minute(self):\nself.assertEqual(zuletzt_gesehen(60),\n\"Zuletzt vor 1 Minute gesehen\")\ndef test_weniger_als_zwei_minuten(self):\nself.assertEqual(zuletzt_gesehen(119),\n\"Zuletzt vor 1 Minute gesehen\")\ndef test_zwei_minuten(self):\nself.assertEqual(zuletzt_gesehen(120),\n\"Zuletzt vor 2 Minuten gesehen\")\nPython MOOC - 4.3 Unit Tests TOC 142/ 145\nTestergebnis interpretieren\npython -m unittest test onlinestatus.py\n## F...F. ## ======================================================================\n## FAIL: test eine minute (test onlinestatus.ZuletztGesehenTest)\n## ----------------------------------------------------------------------\n## Traceback (most recent call last):\n## File \"test onlinestatus.py\", line 11, in test eine minute\n## self.assertEqual(zuletzt gesehen(60), \"Zuletzt vor 1 Minute gesehen\")\n## AssertionError: ’Zuletzt vor 1 Minuten gesehen’ !=\n’Zuletzt vor 1 Minute gesehen’\n## - Zuletzt vor 1 Minuten gesehen\n## ?",
    "-\n## + Zuletzt vor 1 Minute gesehen\n##\n## [...]\n##\n## ----------------------------------------------------------------------\n## Ran 6 tests in 0.001s\n##\n## FAILED (failures=2)\nPython MOOC - 4.3 Unit Tests TOC 143/ 145\nVorteile von Tests\n▶Gesicherte Funktionsweise: Korrektheit der getesteten Einheiten\nbereits w¨ ahrend der Entwicklung pr¨ ufen\n▶Weniger Fehler: Unerw¨ unschte Seiteneffekte fr¨ uh finden\n▶Unterst¨ utzung beim Refactoring: Quellcode ohne Angst ¨ andern\n▶Reflektierte Strukturierung: Code Design gut ¨ uberlegen\n▶Zufriedenheit bei der Entwicklung: dem Ergebnis vertrauen und\nmanuelles Testen vermeiden\n▶Code testgetrieben entwicklen (TDD, Test-driven development):\n▶Zuerst den Test schreiben ( test onlinestatus.py )\n▶Danach die eigentliche Implementierung ( onlinestatus.py )\nKurzfristig: die Entwicklung verlangsamt sich\nLangfristig: der Code wird stabiler und die Struktur verbessert\nPython MOOC - 4.3 Unit Tests TOC 144/ 145\nZusammenfassung f¨ ur 4.3 Unit Tests\nCode systematisch pr¨ ufen:\n▶abgeschlossene Einheiten (Units) auf korrekte Funktion ¨ uberpr¨ ufen\nimport unittest # Modul importieren\nfrom datei import funktion # Code importieren\nclass FunktionsTest(unittest.TestCase):\ndef test_rueckgabe(self): # Testfall definieren\nself.assertEqual(funktion(0), \"Sollwert\")\nif __name__ == \"__main__\":\nunittest.main()\n▶F¨ ur die Test-Klasse immer (unittest.TestCase) angeben\n▶Jede Test-Methode mit test beginnen und (self) angeben\n▶Weiterf¨ uhrendes Material: Beispiele unterschiedlicher Testverfahren,\nUnittest-Dokumentation (English), assert-Methoden\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 4.3 Unit Tests TOC 145/ 145\n[Image 1 OCR]\nPython\nschnell und intensiv Programmieren lernen\n\nBerry Boessenkool [@E@F frei verwenden, zitieren 2024-10-30 21:12\n\nPython MOOC Toc 1/145\n\n[Image 2 OCR]\n1. Intro 1.1 Willkommen\n\nPython MOOC - 1.1 Willkommen. TOC 2/145\n\n[Image 3 OCR]\nWillkommen\n\nBerry\n\n2008-2017 Geodkologie @ Uni Potsdam\n\n\"versehentlich” ein “R-Fan geworden\n\nPakete cs Community BERLIN, Training & Beratung GB\n\nseit 2019 in Teilzeit Dozent am HPI (Lehrstuhl Bert Arnrich)\nseit 2021 auch @-Unterricht\n\nvvvvvy\n\nPython MOOC - 1.1 Willkommen TOC 3/145\n\n[Image 4 OCR]\nKursphilosophie a\n\nPython Grundlagen in ziigigem Tempo\nRechne mit 5-10 Stunden Aufwand pro Woche! Trotz Kl-Assistenten: selbst programmieren (lernen) kénnen\n\nZiel: effizient und reproduzierbar arbeiten\n\n> Python Eigenschaften (Quelle):\n\ninterpretierte Sprache (keine Kompilierung)\n\ndynamische Typisierung (Datentypen werden zur Laufzeit iberpriift)\nobjektorientiert (Daten mit Methoden)\n\nhigh-level (von Menschen lesbar)\n\nvvvyv\n\nv\n\nEingesetzt in Data Science, Machine Learning, Webentwicklung,\nSpielentwicklung, Robotik, autonome Fahrzeuge, Entwicklung\ngraphischer Nutzeroberflachen, Finanzwesen, ...",
    "Python MOOC - 1.1 Willkommen TOC 4/145\n\n[Image 5 OCR]\nKursablauf\n\n> 14 Lektionen\n\nVideo\nPDF (pro Woche KursPDF mit allen Folien) mit\n# Python Code auf grauem Hintergrund\n\nvv\n\nMultiple Choice Quiz (Selbsttest)\nAutomatisch bewertete Programmieraufgaben\nZeit und Dauer der Bearbeitung frei wahlbar\n> Kursinhalte in der Kursbeschreibung\n\nvvv\n\n> pro Kurswoche (fiir einen Leistungsnachweis)\n> Multiple Choice Quiz (Hausaufgabe)\n> Nach Beginn 60 Minuten Zeit\n> Fragen\n> Kursforum [Diskussionen] + Kommentaranfragen\n> Themenbezogene Fragen unter den Videos stellen\n> Beitragstitel zum leichten Suchen im Format \"1.3 A5\" beginnen\n> Gegenseitig beantworten und intensiver lernen! Python MOOC - 1.1 Willkommen TOC 5/145\n\n[Image 6 OCR]\nRessourcen a\n\nDownload & Installation, Hinweise fiir Windows\noffizielle Dokumentation und Sprachreferenz\nDrucken: RefCard, zB. Laurent Pointal, Berry (nah am Kurs), Suche\n\ncodingame.com: Programmierwettbewerbe mit Suchtpotenzial\n\n> Ausfiihrlichere (langsamere) Kurse:\n> openHPI deutscher Python Junior Kurs\n> bodenseo deutsche Webseite + Buch\n> Computer Science Circles interaktiver englischer Kurs\n> Python.org offizielles englisches Tutorial\n\nPython MOOC - 1.1 Willkommen TOC 6/ 145\n\n[Image 7 OCR]\nIntegrated development environment (IDE)\n\nProgrammieraufgaben sind im Browser losbar\n\nIm echten Leben lokal arbeiten - in einer Entwicklungsumgebung\nFiir Python gibt es Hunderte IDEs (Top 9, RStudio)\n\nIch empfehle VS Code (ggf. Telemetry ausschalten)\n\nfiir viele Sprachen, z.B. Python, R, Julia, JavaScript, C++, SQL\n\nkann Script ausfiihren oder einzelne Zeilen (Demo)\n\nvvvvvvy\n\nWer’s braucht: Jupyter notebooks (Julia, Python, R), zB. google\n\nPython MOOC - 1.1 Willkommen TOC 7/145\n\n[Image 8 OCR]\nProgrammieraufgaben\n\nZu jeder Lektion gibt es interaktive Code-aufgaben im Browser. 1.1 Programmieraufgaben\n\nItem bearbeiten\n\nAnweisungen:\nKlicke unten um die Aufgabe zu 6ffnen. 395 Dies ist eine unbenotete Aufgabe. \\ 2.0 Punkte\n\ngabe starten\n\nDer Zugang erfolgt via openHPI (nicht direkt per URL). Python MOOC - 1.1 Willkommen TOC\n\n8/ 145\n\n[Image 9 OCR]\nProgrammieraufgaben in CodeOcean a\n\nDateien 15 a jeer A\n~ B siplt1_seriptt py. Die letzte Code-Ausfuhrung wurde erfolgreich beendet (Statuscode 0). Runterladen (lokal bearbeiten)\n\nAlle Skripte dieser Lektion (heiBt hier \" Aufgabe” ) zuriicksetzen\nSkript ausfiihren lassen\n\nKomplette Aufgabe bewerten lassen\n\nKommentaranfrage stellen (fiir individuelle Hilfe)\n\naaP Wn re\n\n(unten): ein einzelnes Skript zuriicksetzen\n\nPython MOOC - 1.1 Willkommen TOC 9/ 145\n\n[Image 10 OCR]\nProgrammieraufgaben Hinweise a\n\nSollte beim Bewerten rechts unten mal ERROR: test** statt FAIL: stehen,\nbitte den Fehler verzeihen und die Nachricht im Forum melden. Es ist nicht notig, 100% zu erreichen um mit anderen Aufgaben im Kurs\nweiterzumachen.",
    "Ich teile keine gebiindelten Musterlosungen:\n\n> es schrankt deine Kreativitat und Diversitat ein (es gibt meistens mehrere\nLosungswege)\n\n> es geht viel Lerneffekt verloren, wenn man dann doch \"kurz reinschaut”\n> du musst unbedingt lernen, selbst Lésungen zu finden\n\n> zu einzelnen Aufgaben darfst du im Forum nach besseren Ansatzen fragen\n(didaktisch wertvoll). Schaue auch gerne in die Kommentaranfragen\nanderer Teilnehmer rein. > das Testskript schaut bereits, ob deine Losung generalisiert anwendbar ist\n\n> Good Coding ist eine Stilfrage, wo ich nicht allzuviel vorschreiben mdchte\n\nPython MOOC - 1.1 Willkommen TOC 10/ 145\n\n[Image 11 OCR]\nZusammenfassung fur 1.1 Willkommen\n\nVorstellung, Python, Programmieraufgaben:\n\n> Programmieren ist eine machtige Kompetenz\n\n> Python ist toll\n\n> Fragen im Forum stellen und beantworten\n\n> RefCard drucken\n\n> Wenn du lokal arbeiten willst: Python und VScode installieren\n> Programmieraufgaben mit automatischer Bewertung\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.1 Willkommen TOC 11/145\n\n[Image 12 OCR]\n1. Intro\n1.2 Syntax\n\nPython MOOC - 1.2 Syntax TOC 12/145\n\n[Image 13 OCR]\nOperatoren, Kommentare a\n\n5 + 8 # Kommentare (nach einer Raute) werden ignoriert\n## 13\n\n6/7 # Leerzeichen sind irrelevant (hier)\n\n## 0.8571428571428571\n\n12 * 3.4 # Dezimalzahlen mit einem Punkt angeben\n\n## 40.8\n\n3 ** 2 # Exponenten (nicht 372!)\n\n## 9\n\n19 // 3 # ganzzahlige Division\n\n## 6\n\n19 % 3 # Modulo (Rest nach ganzahliger Division)\n## 1\n\nDies ist ein Kommentar\nuber mehrere Zeilen. -> Gut zum Dokumentieren von Code :)\ntt\n\nPython MOOC - 1.2 Syntax TOC 13/145\n\n[Image 14 OCR]\nObjekte, Ausgaben auf der Konsole (shell / terminal) a\n\nObjekt erstellen mit = Zeichen:\n\nx = \"Hallo, python Welt!\"\nx\n## ‘Hallo, python Welt!'\n\nZeichenketten sind erstellbar mit \"und ’ . In den meisten Umstanden (z.B. VS Code, CodeOcean), braucht es einen\nexpliziten Aufruf, um etwas in der Konsole anzuzeigen:\n\nprint (x)\n## Hallo, python Welt! print braucht man nicht in jupyter notebooks, bei zeilenweiser\nAusfiihrung und in diesen Folien (erstellt mit Rnw = “R + TEX). Wenn du in VScode Befehle zeilenweise ausfiihrst (>>> in console),\nkannst du mit quit) wieder in den normalen Modus wechseln. Python MOOC - 1.2 Syntax TOC 14/ 145\n\n[Image 15 OCR]\nprint\n\nprint(\"Ich schreibe: \", x)\n\n## Ich schreibe: Hallo, python Welt!",
    "print konkateniert verschiedene Eingaben, getrennt durch sep\n(default \" \" ) und abgeschlossen mit end (default \"\\n\" )\na=5\n\nprint(\"a ist:\", a, \"gut\", sep=\"0\", end=\"\\n\\n\\n\")\nprint(\"a ist immer noch:\", a)\n\n## a ist:050gut\n\n##\n\n## a ist immer noch: 5\n\nprint(\"Berlin\", end = \"#\")\n\nprint (\"Potsdam\")\n\n## Berlin#Potsdam\n\nPython MOOC - 1.2 Syntax TOC 15/145\n\n[Image 16 OCR]\nHaufige Fehler bei Objektnamen a\na = 42\n\nGroB-/Kleinschreibung beachten:\n\nA + 88\n\n## NameError: name ’A’ is not defined\nObjektnamen diirfen nicht mit Zahlen beginnen:\n12b = 67 / 5\n\n## SyntaxError: invalid decimal literal\n\nSchliisselworter diirfen nicht als Objektnamen verwendet werden:\nclass = 4\n## SyntaxError: invalid syntax\n\nAusfihrliche Liste haufiger Fehler, Liste der reservierten Keywords\nSyntaxError: oft Klammern oder Doppelpunkte vergessen (in Schleifen)\n\nObjektnamen sollten kurz und informativ sein,\nz.B. anzahl_teilnehmer oder video_dauer\n\nPython MOOC - 1.2 Syntax TOC 16/145\n\n[Image 17 OCR]\nObjektmethoden |\n\neine_liste = [42, 77, -5, 6]\n\neine_liste\n\n## (42, 77, -5, 6]\n\neine_liste. (111) # Methode fir Listenobjekte\n\nDas Objekt wird verandert, ohne es neu zuzuweisen\n(wenn es veranderbar ist, siehe Lektion 2.1 Objekttypen). eine_liste\n\n## [42, 77, -5, 6, 111]\n\nPython MOOC - 1.2 Syntax Toc\n\n17/145\n\n[Image 18 OCR]\nObjektmethoden II a\n\nWenn eine Methode ein Objekt zuriickgibt, kénnen Methoden verkniipft\nwerden (chaining):\nsatz = \"Eine normale Zeichenkette\"\n\nsatz.count(\"e\") # zadhlt nur kleine e\n## 6\n\nsatz.lower() # macht alles klein\n\n## ‘eine normale zeichenkette'\n\nsatz.lower().count(\"e\") # za@hlt alle e\n## 7\n\nPython MOOC - 1.2 Syntax TOC 18/145\n\n[Image 19 OCR]\ninteraktive Nutzereingabe\n\nnutzer_eingabe = input()\nprint(\"Die Eingabe war:\", nutzer_eingabe)\nnutzer_eingabe = input(\"Bitte etwas eingeben: \")\n\nDie Ausgabe von input ist immer eine Zeichenkette (string), auch\nwenn eine Zahl eingegeben wird. Python MOOC - 1.2 Syntax TOC 19/145\n\n[Image 20 OCR]\nFunktionen aus Modulen\n\nGrundlegende Befehle wie print , +, input, etc sind immer\n\nverfiigbar. Funktionen wie sqrt sind in einem eigenen Paket (Modul). Diese miissen zuerst geladen werden:\n\nimport math\n\nmath.sqrt (700)\n## 26.457513110645905\n\nWeitere Methoden in Lektion 1.5 Module importieren\n\nPython MOOC - 1.2 Syntax TOC 20/145\n\n[Image 21 OCR]\nZeilen einer Textdatei lesen\n\nfname = \"textDatei.txt\"\nwith open(fname) as f:\ninhalt = f.readQ # .splitlines()\nprint (inhalt)\n## Dies ist ein kleines Beispiel einer Textdatei\n## um das Einlesen von Zeilen in Python zu demonstrieren. ## Fiir echte Daten das Paket “pandas” verwenden!",
    "open(\"textDatei.txt\") offnet die Datei im Lesemodus\n\nwith garantiert, dass die Datei am Ende geschlossen wird (besonders\nim Falle eines Fehlers)\n\nDie Zeile nach with muss eingeriickt sein\n\ninhalt.splitlines() gibt eine Liste mit einer Textzeile pro\nListenelement aus\n\nPython MOOC - 1.2 Syntax TOC 21/145\n\n[Image 22 OCR]\nkiirzere Zuweisungen |\n\nIn der DataScience als schlecht lesbar angesehen und nicht sehr\nempfohlen, wird aber besonders in Schleifen durchaus verwendet. Python MOOC - 1.2 Syntax TOC 22/145\n\n[Image 23 OCR]\nZusammenfassung fiir 1.2 Syntax\n\nSyntax, Objekte, Operatoren, Funktionen:\n\n>\n>\n\nvvveyvyy\n\n+, -, *, J, **, //, %\n\nobj = \"string\" # Kommentar ;\n\nmehrzeiliger Kommentar\nprint(\"Zeichen\", 42, obj, sep=\"\", end=\"\\n\")\nobj.method() ; string. lower().count(\"p\")\nnutzer_eingabe = input()\n\nimport modul ; modul.funktion(x)\n\nwith open(\"datei.txt\") as f: inhalt = f.read()\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.2 Syntax TOC 23/145\n\n[Image 24 OCR]\n1. Intro\n\n1.3 Datentypen\n\nPython MOOC - 1.3 Datentypen TOC 24/145\n\n[Image 25 OCR]\nDatentypen\n\nWir haben schon drei Sorten von Daten gesehen: ganze Zahlen,\nKommazahlen und Zeichenketten. type (5)\n\n## <class 'int'>\n\ntype (5.67)\n\n## <class 'float'>\ntype(\"Zeichen\")\n\n## <class 'str'>\n\nprint(7 > 4, 7 < 4)\n\n## True False\n\ntype(7 > 4)\n\n## <class 'bool'>\n\ntype(2+3j) # Komplexer Teil mit 7 statt mit 7\n## <class 'complex'>\n\nPython MOOC - 1.3 Datentypen Toc\n\n25/ 145\n\n[Image 26 OCR]\nDatentyp priifen\n\nisinstance\n\nsinstance\n\nPython MOOC - 1.3 Datentypen TOC 26/145\n\n[Image 27 OCR]\nDatentyp andern (konvertieren) |\n\ninvalid literal for int() with base 10:\n\nPython MOOC - 1.3 Datentypen TOC 27/145\n\n[Image 28 OCR]\nTypenkonvertierung Demo\n\nPython MOOC - 1.3 Datentypen\n\nTOC\n\n28/ 145\n\n[Image 29 OCR]\nZusammenfassung fiir 1.3 Datentypen\n\nDatentypen ermitteln:\n\ntype (objekt)\n\nv\n\nint (etwas_das_konvertiert werden kann)\nP isinstance(objekt, int)\n> isinstance(objekt, (float, int, str) )\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.3 Datentypen TOC 29/145\n\n[Image 30 OCR]\n1. Intro\n\n1.4 Funktionen schreiben\n\nPython MOOC - 1.4 Funktionen schreiben TOC 30/145\n\n[Image 31 OCR]\nFunktionssyntax |\n\ndef willkommen(name, zeit=\"morgen\"):\nmsg = \"Hallo, \" + name + \". Guten \" + zeit + \"!\"\nreturn msg\n\nwillkommen(name='Bob', zeit='Abend')\n\n## 'Hallo, Bob. Guten Abend!'\n\nwillkommen(name='Berry') # mit dem Standardfall (morgen)\n## 'Hallo, Berry.",
    "Guten morgen!'\n\n> Doppelpunkt : notwendig, danach einrticken\nmit Leerzeichen oder Tabstop, Hauptsache einheitlich\n\nOhne explizites return gibt eine Funktion None zurtick\n\n>\n\n>\n\n> return beendet den Funktionsaufruf\n\n> name & zeit sind Parameter, \"Berry’ & \"Abend” sind Argumente\n>\n\nSyntax: parameter=argument\n\nPython MOOC - 1.4 Funktionen schreiben TOC 31/ 145\n\n[Image 32 OCR]\nFunktionssyntax II a\n\n> Parameternamen kénnen beim Aufruf weggelassen werden, sofern\ndie Argumente in der richtigen Reihenfolge gegeben werden:\nwillkommen(\"Lydia\", \"Mittag\")\n## 'Hallo, Lydia. Guten Mittag!'\n\nprint() zeigt eine Ausgabe in der Konsole an. return beschreibt den Funktionsriickgabewert,\nder danach zugewiesen werden kann\n\nund mit dem weitergearbeitet werden kann. vvvvy\n\nIn der Realitat eigentlich immer return verwenden\n\nv\n\nDas Wort \"ausgeben” wird fiir \"zuriickgeben” und \" anzeigen”\nverwendet. In den Programmieraufgeben ist meist return oder\n\nprint vorgegeben. > IndentationError: Zu wenig oder zu viel Einriickung\n\nPython MOOC - 1.4 Funktionen schreiben TOC 32/145\n\n[Image 33 OCR]\nBeispiel einer Funktion a\n\nimport math\n\ndef kugel_volumen_berechnen (radius, nachkommastellen=3) :\nvolumen = (4/3) * math.pi * radius**3\ngerundet = round(volumen, nachkommastellen)\nreturn gerundet\n\nkugel_volumen_berechnen (2)\n\n## 33.51\nkugel_volumen_berechnen(2, 5)\n## 33.51032\n\nWas ist hier gut? > Funktionsname ist ein Verb\n> Parameternamen erklaren sich selbst\n> gute Objektnamen innerhalb der Funktion\n> math auBerhalb der Funktion importiert\n\nPython MOOC - 1.4 Funktionen schreiben TOC 33/145\n\n[Image 34 OCR]\nScoping (Giltigkeitsbereich) - welche Objekte werden gefunden |\nLokale Objekte in einer Funktion haben Vorrang:\nimport math\ndef tische_zaehlen(n):\ntische = n/6\naufgerundet = math.ceil(tische)\nreturn aufgerundet\n\nanzahl_gaeste = 78\n\ntische_zaehlen(anzahl_gaeste)\n\n## 13\n\ntische = 4000\n\ntische_zaehlen(22) # Funktion verwendet internes Objekt\n## 4\n\naufgerundet\n\n## NameError: name ’aufgerundet’ is not defined\n\nLokale objekte (innerhalb einer Funktion) sind temporar und nach der\nAusfihrung der Funktion nicht global verfiigbar\n\nPython MOOC - 1.4 Funktionen schreiben TOC 34/145\n\n[Image 35 OCR]\nScoping (Giltigkeitsbereich) - welche Objekte werden gefunden II a\n\nGlobale Objekte sind in einer Funktion verfiigbar:\n\ndef anzahl_stuehle(n):\nreturn anzahl_gaeste\n\nanzahl_stuehle(17)\n\n## 78\n\nMit globalen Objekten innerhalb einer Funktion nur arbeiten, wenn man\nweiB, was man tut! Python MOOC - 1.4 Funktionen schreiben TOC 35/ 145\n\n[Image 36 OCR]\nZusammenfassung fur 1.4 Funktionen schreiben wa\n\nwiederverwendbare Codeblocke:\n\n> Funktionssyntax:\ndef funktionsname (parameter, mit_default=\"argument\"):\nausgabe = parameter + 5\nreturn ausgabe\nparameter + 8 # code nach return nie ausgefihrt\n\n> Einriickung einheitlich\n\nP print vs return beachten\n\n> lokale Objekte existieren nur innerhalb der Funktion\n> globale Objekte nicht in einer Funktion verwenden\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.4 Funktionen schreiben TOC 36/ 145\n\n[Image 37 OCR]\n1.",
    "Intro\n\n1.5 Module importieren\n\nPython MOOC - 1.5 Module importieren TOC 37/145\n\n[Image 38 OCR]\nEingebaute Pakete (Module) a\n\nPython kommt mit einigen Modulen vorinstalliert (Standardbibliothek). Diese miissen nicht installiert werden (Liste). Zur verwendung in einem Skript miissen sie aber geladen werden. import math\n\nradius = float(input('Bitte Radius eingeben: '))\nprint(\"Der Umfang ist \", 2 * math.pi * radius)\n\nGute Praxis beachten:\n\nfrom math import * # NICHT BENUTZEN! from math import sqrt, pi # schwer nachvollziehbar\nimport math # sauber, lesbar\nmath.pi # -> Kénigsweg\nimport math as m # etwas kitirzer\nm.pi # pandas -> pd\n\nPython MOOC - 1.5 Module importieren TOC 38/145\n\n[Image 39 OCR]\nExterne Module a\n\nPopulare Pakete\n\nseer Re & nee > Data science: numpy , pandas\n2 bokeh eB. > Machine learning: tensorflow, pytorch\ney ee pandas» Statistical analysis: |scipy\ny. pyTrcH ees > Web application: django\nQuelle > Plotting: matplotlib, seaborn\n\nModule von pypi.org (PYthonPackagelndex) installieren mit pip (bei\nPython inklusive). In Konsole / Terminal / Shell / bash / cmd:\n\npip install numpy # pip3 unter MacOS\n\npip list\n\nAuf dem Macbook mache ich das mit R:\n\ninstall.packages (\"reticulate\")\nreticulate: :install_miniconda()\nreticulate: :py_install(\"numpy\")\n\nImportError: Name falsch geschrieben? Python MOOC - 1.5 Module importieren TOC 39/145\n\n[Image 40 OCR]\nBeispiele fiir Paketnutzungen a\n\nZufallszahlen:\n\nimport random\n\nrandom.random() # float von O (inkl) bis 1 (exklusive)\nrandom.randint(1, 6) # int von 1 (inkl) bis 6 (inkl!!!)\n\nZahlung:\n\nimport collections\n\nf = ['rot', 'blau', 'blau', ‘'gelb', 'blau', 'rot', 'lila']\ncollections .Counter (f) .most_common(3)\n\n## [('blau', 3), ('rot', 2), ('gelb', 1)]\n\nMehrere Module kénnen in einer Zeile importiert werden:\nimport collections, statistics, random\n\nPython MOOC - 1.5 Module importieren TOC 40/145\n\n[Image 41 OCR]\nEinlesen (Ausfiihren) von .py Dateien\n\nArbeitsverzeichnis (Pfad, Ordner), current working directory:\n\nimport os\nos.getcwd().replace(os.sep, ‘/')\n## 'C:/Dropbox/pymooc/folien'\n\nSiehe auch das Modul pathlib\n\nDort liegt meinskript.py mit anzahl = 25. from meinskript import anzahl\n\nprint (anzahl+2)\n\n## 27\n\nBeachte: kein echter Dateiname (mit .py-Endung)! import meinskript\nmeinskript.anzahl\n## 25\n\nPython MOOC - 1.5 Module importieren Toc\n\n41/145\n\n[Image 42 OCR]\nObjekte in .py-Dateien\n\nimport meinskript\n\nprint(\"\\n\". (dir(meinskript))) # Objekte im Modul\n## __builtins__\n## __cached__\n## __doc__\n\n## __file__\n\n## __loader__\n## __name__\n\n## __package__\n## __spec__\n\n## anzahl\n\n## job\n\n## random\n## simuliere_job\n\nPython MOOC - 1.5 Module importieren TOC 42/145\n\n[Image 43 OCR]\nFunktionen in .py-Dateien\n\ntype (meinskript .simuliere_job)\n## <class 'function'>\n\nmeinskript.simuliere_job()\n\n## 'coder'\nmeinskript.simuliere_job()\n## ‘arzt'\n\nimport inspect\n\nprint (inspect. getsource (meinskript .simuliere_job))\n## def simuliere_job():\n\n## jobs = [\"lehrer\",\"handwerker\",\"arzt\",\"coder\"]\n## return random.choice(jobs)\n\nWenn Argumente vorhanden sind:\ninspect.getfullargspec(meinskript.simuliere_job)\n## FullArgSpec(args=[], ... defaults=None ...",
    "Python MOOC - 1.5 Module importieren TOC 43/145\n\n[Image 44 OCR]\nZusammenfassung fiir 1.5 Module importieren\n\nModule und Skripte importieren:\n> import paket as pak ; pak.fun()\n> from paket import fun ; fun()\n> pip install externes_paket in einer Konsole\n> from lokale_python_datei import ein_objekt\n> inspect.getsource(eine function)\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.5 Module importieren\n\nTOC\n\n44/ 145\n\n[Image 45 OCR]\n1. Intro\n\n1.6 Zeichenketten\n\nPython MOOC - 1.6 Zeichenketten TOC 45/145\n\n[Image 46 OCR]\nTeile von Zeichenketten auswahlen (subsetting, indexing)\n\nk = \"Hallo, Welt!\"\n\nk[7] # 8. Buchstabe\n\n## 'W'\n\nPython indiziert ab 0! k[3:7] #4. bis 7. (rechts\nexklusiv des 8.)\n\n## ‘lo, ! k[:6] # 1. bis 6. ## 'Hallo,'\n\nk [400]\n## IndexError:\n\nk[3.5]\n## TypeError:\n\nk[2:] # 3. bis letzte\n## 'llo, Welt!'\n\nk[-2] # vorletze\n\n## 't! k[-5:-2] # kombinierbar\n## 'Wel'\n\nk[5:-2] # gemischt geht\n## =', Wel'\n\nstring index out of range\n\nstring indices must be integers\n\nk[2] = 'K' # strings sind nicht dnderbar (siehe 2.1)\n\n## TypeError:\n\nPython MOOC - 1.6 Zeichenketten\n\n*str’ object does not support item assignment\n\nTOC 46/145\n\n[Image 47 OCR]\nOperatoren fiir Zeichenketten a\n\na = \"Hallo\"\n\nlen(a) # Anzahl Zeichen\n\n## 5\n\n\"Zeichen ' + \"Kette \" + a # zusammenftigen\n\n## 'Zeichen Kette Hallo'\n\n\"Zeichen \" + \"Kette \"+ 77\n\n## TypeError: can only concatenate str (not \"int\") to str\n\n3 * a # wiederholen\n\n## 'HalloHalloHallo'\n\n38/a\n\n## TypeError: unsupported operand type(s) for /: ?int’\nand ’str’\n\n\"lo\" in a # Prdsenz prtfen\n## True\n\nPython MOOC - 1.6 Zeichenketten TOC 47/145\n\n[Image 48 OCR]\nZeichenketten aufteilen und zusammenfiihren\n\nzk = \"Etwas Text und einige Worte\"\n\nzk.split() # Ausgabe: Liste. Standard: sep=\" \"\n## ['Etwas', 'Text', 'und', 'einige', 'Worte']\nzk # immutable: nicht veradndert\n\n## 'Etwas Text und einige Worte'\n\nprint(\"Zeichenkette mit\\nZeilenumbruch\")\n## Zeichenkette mit\n## Zeilenumbruch\n\n\"Zeichenkette mit\\nZeilenumbruch\".split(\" \")\n## ['Zeichenkette', 'mit\\nZeilenumbruch']\n\n\"Zeichenkette mit\\nZeilenumbruch\".split()\n## ['Zeichenkette', 'mit', 'Zeilenumbruch']\n\n# sep Default ist jede Art von Leerzeichen, inkl. \\n\n\n\"_\".join([\"Liste\", \"mit\", \"Worten\"])\n## 'Liste_mit_Worten'\nPython MOOC - 1.6 Zeichenketten TOC 48/ 145\n\n[Image 49 OCR]\nZeichenketten mit Objektbezug: F-strings\n\nname=\"Berry\" 5; anzahl=7\n\nf\"Ich bin {name} und habe {anzahl} Katzen.\"\n## 'Ich bin Berry und habe 7 Katzen.'\n\nf\"Ich bin {name} und habe {anzahl+4} Katzen.\"\n## 'Ich bin Berry und habe 11 Katzen. '\n\nsiehe realpython.com\n\nPython MOOC - 1.6 Zeichenketten TOC\n\n49/ 145\n\n[Image 50 OCR]\nZusammenfassung fiir 1.6 Zeichenketten\n\nZeichenketten (strings) verarbeiten:\n\n> string [position]\n\nlen(string)\n> +, *, in\n> string.split() , string.",
    "join()\n> f\"string mit {Objekt} Referenz\"\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 1.6 Zeichenketten TOC\n\n50/ 145\n\n[Image 51 OCR]\n2.1 Objekttypen\n2. Objekte\n\nPython MOOC - 2.1 Objekttypen TOC 51/145\n\n[Image 52 OCR]\nObjekte sind zum Teil veranderbar\n\nIn Python sind einige Objekte veranderbar (mutable):\neine_liste = [1,2,3]\n\neine_liste[1i] = 99 # Listen sind verdnderbar\neine_liste\n## [1, 99, 3]\n\neine_liste.append(77) # Methode = Funktion einer Klasse\n\neine_liste # verdndert, ohne neue Zuweisung\n## [1, 99, 3, 77]\n\nZeichenketten sind nicht veranderbar:\n\nkette = \"Python ist toll\"\n\nkette[11] = \"T\"\n## TypeError: ’str’ object does not support item\nassignment\n\nPython MOOC - 2.1 Objekttypen TOC 52/145\n\n[Image 53 OCR]\nTupel\n\n> Ahnlich wie Listen\n\n(4, 8, 4, -3.14)\n> ## (4, 8, 4, -3.14)\n\n(4, 8, \"“drei\") # kénnen gemischte Datentypen sein\n> ## (4, 8, 'drei')\n> Oft als Subelement einer Liste genutzt\n> um verschachtelte Klammern lesbar zu halten\n\n((8,5), 9, 3, (4,7)]\n> ## [(8, 5), 9, 3, (, 7]\n\nPython MOOC - 2.1 Objekttypen TOC 53/145\n\n[Image 54 OCR]\nMehrfachzuweisung\n\nMehrfachzuweisung (multiple assignment) in einer Zeile\n\ndef eingaben_verdoppeln(x, y):\nreturn x*2, y*\n\nergebnis = eingaben_verdoppeln(3, 4)\nergebnis # ein Tupel\n\n## (6, 8)\n\na, b = eingaben_verdoppeln(3, 4)\n\na # zwei separate Objekte\n\n## 6\n\nb\n\n## 8\n\nTauschen zweier Variablen:\na, b=b, a # rechte Seite wird zuerst ausgefuhrt\n\nPython MOOC - 2.1 Objekttypen TOC\n\n54/ 145\n\n[Image 55 OCR]\nMengen (sets)\n\nsi = {1,2,3,4, }\ns2 = { »4,5,6,7,8}\n\nOperatoren wie in mathematischen Mengen\n\nsi | s2 # Vereinigung\n\n## {1, 2, 3, 4, 5, 6, 7, 8}\n\nsi & s2\n## {3, 4, 5}\n\n# Schnitt\n\nsi - s2 # Differenz: in s1, nicht in s2\n\n## {1, 2}\n\ns2- st\n\n## {8, 6, 7}\n\n# zeigt, dass die Eintrdge nicht geordnet sind\n\n{} # leeres Dictionary (nicht Menge!)\nset() # leere Menge\n\nPython MOOC - 2.1 Objekttypen\n\nTOC\n\n55/ 145\n\n[Image 56 OCR]\nMengen haben einmalige Werte\nzahlen = [6, 3, 3, 4]\n\nWenn Listen in ein Set konvertiert werden, sind die Eintrage (mogliche\nAuspragungen) nur einmal drin:\n\nset (zahlen)\n## {3, 4, 6}\n\nset([6, 3, \"3\", 4])\n## {3, 4, 6, '3'}\n\n\"3\" ist was anderes als 3\n\nNeue Werte konnen hinzugeftigt werden:\n\nsi = {1,2,3,4,5}\n\nsi.",
    "(7)\n\nsi\n\n## {1, 2, 3, 4, 5, 7}\n\nPython MOOC - 2.1 Objekttypen TOC 56/145\n\n[Image 57 OCR]\nObjekttypen (Collections) Ubersicht\n\nTyp Beispiel | anderbar | geordnet indiziert Duplikate\nListe [1,3] ja ja ja ok\nTupel | (1,2) nein ja ja ok\nMenge | {1,4} ja * nein nein nein\nDict {\"a\":7, | ja nein / ja seit | mit nein **\n\n\"pb\" :6} Python 3.6 Schliissel\n\n*: die Elemente miissen immutable sein\n**: die Schliissel miissen einmalig sein, Werte sind mehrfach erlaubt\n\nListe: verschiedene Daten\nTupel: gruppieren verwandter Daten\nMenge: schnelle Uberpriifung, ob ein Wert enthalten ist\n\nDictonary: schnelles Abrufen anhand von Schliisselnamen\n\nPython MOOC - 2.1 Objekttypen\n\nTOC 57/145\n\n[Image 58 OCR]\nZusammenfassung fiir 2.1 Objekttypen\n\nUberblick Objekte, Tupel und Mengen:\n\n> Liste, Tupel, Menge, Dictionary\nP veranderbar, geordnet\n\n> Mengenoperationen\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.1 Objekttypen Toc\n\n58/ 145\n\n[Image 59 OCR]\n2. Objekte 2.2 Listen\n\nPython MOOC - 2.2 Listen TOC 59/145\n\n[Image 60 OCR]\nListe: Erstellung + Teilmengenbildung |\n\nliste = [7, -4, 9, 1, 2, 3, 9, 5]\nlen(liste)\n## 8\n\nliste[0] # erstes Element\n## 7\n\nliste[1] # zweites Element\n## -4\nliste[5] # Element 6\n## 3\nliste[2:5] # Elemente 3,4,5\n## (9, 1, 2]\nBereiche sind exklusiv am rechten Ende\nist auBerhalb der Teilmengenbildung kein Operator\n\nleere_liste = []\n\nPython MOOC - 2.2 Listen\n\nTOC\n\n60/ 145\n\n[Image 61 OCR]\nListe: Erstellung + Teilmengenbildung II\n\nliste\n\n## (7, -4, 9, 1, 2, 3, 9, 5]\n\nliste[4:] # Teilung: fiinftes bis letztes Element\n## [2, 3, 9, 5]\n\nliste[:6] #1. - 6.",
    "## [7, -4, 9, 1, 2, 3]\n\nliste[-2] # vorletztes Element\n\n## 9\n\nliste[2:-3] # hier dquivalent zu liste [2:5]\n## [9, 1, 2]\n\nliste[2] = \"neuerWert\" # tiberschreibe drittes Element\nliste\n\n## (7, -4, 'neuerWert', 1, 2, 3, 9, 5]\n\nverschiedene Datentypen mdglich\n\nPython MOOC - 2.2 Listen TOC 61/ 145\n\n[Image 62 OCR]\nListenelement an Index entfernen a\n\nzahlen = [1,2,3,4,5,6,7]\n\nende = zahlen.pop() # letztes Element entfernen + ausgeben\nende\n\n## 7\n\nzahlen # verdndert, ohne neue Zuweisung\n\n## [1, 2, 3, 4, 5, 6]\n\nzahlen.pop(3) # angegebenes Element entfernen (+ ausgeben)\nzahlen\n\n## 4\n\n## [1, 2, 3, 5, 6]\n\ndel(zahlen[2]) # Element an Index entfernen\nzahlen\n## [1, 2, 5, 6]\n\ndel funktioniert auch ohne Klammern\n\nPython MOOC - 2.2 Listen TOC 62/ 145\n\n[Image 63 OCR]\nListenelement nach Wert entfernen a\n\nwerte = [1,2,3,4,5,6,7,4]\n\nin werte # prtft ob in der Liste, gibt boolean zurtick\n## True\n\nnot in werte # priuft ob nicht in der Liste\n\n## True\n\nwerte. (4) # Index vom ersten Auftreten von 4\n## 3\n\nwerte. (4) # erste Instanz von 4 entfernen\nwerte\n\n## [1, 2, 3, 5, 6, 7, 4]\n\nPython MOOC - 2.2 Listen TOC 63/145\n\n[Image 64 OCR]\nElemente hinzufiigen\n\nwerte. (66) # am Ende anfiigen\nwerte\n## [1, 2, 3, 5, 6, 7, 4, 66]\n\nwerte. (3, \"neu\") # an Position einftigen\nwerte\n## [1, 2, 3, 'neu', 5, 6, 7, 4, 66]\n\nverschiebt Elemente nach Eingefiigtem nach hinten\n\nzahlen + werte[:6]\n## [1, 2, 5, 6, 1, 2, 3, 'neu', 5, 6]\n\nPython MOOC - 2.2 Listen TOC 64/145\n\n[Image 65 OCR]\nListensortierung\n\nj_liste = [7, -4, 9, 1, 2, 3]\nj_liste. 0)\n\nj_liste\n\n## [3, 2, 1, 9, -4, 7]\nj_liste. QO\n\nj_liste\n\n## [-4, 1, 2, 3, 7, 9]\nj_liste. (reverse=True)\nj_liste\n\n## 19, 7, 3, 2, 1, -4]\nk_liste = [7, -4, \"9\", 1, 2, 3]\n\nk_liste. QO\n\n## TypeError: ’<’ not supported between instances of\n*str’ and ’int’\n\nPython MOOC - 2.2 Listen TOC 65/ 145\n\n[Image 66 OCR]\nListenverschachtelung + verlangerung a\nm_liste = [1, 2, 3, [31,32,33], 4] # Verschachtelung OK\n\nch_liste = [\"Worter\",\"mit\",\"vielen\",\"Buchstaben\"]\nch_liste[2][5] # fortlaufend indiziert: Wort 3, Buchst.",
    "6\n## 'n'\n\nx= [1, 2, 3, 4]\n\ny = [5, 6]\n\nz= (7, 8, 9]\nx.extend(ly) # dndert lx\nx\n\n## [1, 2, 3, 4, 5, 6]\n\nx + ly # dndert lx nicht, daftir: lx = lx + ly\n## [1, 2, 3, 4, 5, 6, 5, 6]\n\nZz *\n## [7, 8, 9, 7, 8, 9]\n\nPython MOOC - 2.2 Listen TOC 66/ 145\n\n[Image 67 OCR]\nListen zusammenfiihren\n\nwoerter = [\"mehrere\", \"Wérter\"]\n\"\\n\", (woerter)\n\n## 'mehrere\\nWorter'\nprint(\"\\n\". (woerter) )\n\n## mehrere\n\n## Worter\n\ngemischt = [99, \"“Luftballons\"]\nprint(\"\\n\". (gemischt) )\n\n## TypeError: sequence item 0: expected str instance,\nint found\n\n# Stern (splat) Operator entpackt Liste\n\nprint (*gemischt, sep=\"\\n\")\n\n## 99\n\n## Luftballons\n\nPython MOOC - 2.2 Listen TOC 67/145\n\n[Image 68 OCR]\nListen umkehren (Aufgabe) a\n\nKorrigiere den Fehler im folgenden Code. Warum tritt er auf? Python MOOC - 2.2 Listen TOC 68/ 145\n\n[Image 69 OCR]\nListen umkehren (Ldsung)\n\nDie Listenmethode ‘reverse’ andert die Liste selbst, da das ein\nveranderbares Objekt ist. Sie wird fiir den Seiteneffekt aufgerufen, daher ” gibt sie nichts zuriick”. Sie gibt None zuriick, was ‘liste’ tberschrieben hat. liste = [\"al\", \"bi\", \"b2\", \"b3\", \"b4\", \"b5\", \"ci\", \"d1\"]\nliste.reverse()\n\nprint (liste [2])\n\n## bS\n\nPython MOOC - 2.2 Listen TOC 69/ 145\n\n[Image 70 OCR]\nListe kopieren fiir eine unabhangige Instanz a\nliste = [1,2,3,4,5,6]\n\nandere_liste = liste\nandere_liste\n## [1, 2, 3, 4, 5, 6]\n\nliste.append(9)\n\nandere_liste # hat sich auch verdndert! ## [1, 2, 3, 4, 5, 6, 9]\n\nReferenziert dasselbe Objekt im Arbeitsspeicher(Pointer, id(objekt) )\n\ndritte_liste = liste.copy() # unabhdngige Kopie\ndritte_liste\n## [1, 2, 3, 4, 5, 6, 9]\n\nliste[1] = 99\n\ndritte_liste # wurde nicht verdndert\n## [1, 2, 3, 4, 5, 6, 9]\n\nPython MOOC - 2.2 Listen TOC 70/145\n\n[Image 71 OCR]\nGiiltigkeitsbereich (Scope) in Funktionen (Quelle)\n\n# Liste in einer Funktion ktirzen\ndef maxOhne5(11):\n11.remove(5)\nreturn max(11)\n# verdndert globale Liste (verdnderbares Objekt)\n\nliste_a = [1,2,3,4,5]\n\nprint (liste_a) # [1, 2, 3, 4, 5]\nprint (maxOhne5(liste_a)) #4\nprint (liste_a) # [1, 2, 3, 4] <-- verdndert!",
    "def maxOhne5(11):\n11 = ll.copy() # lokale Kopie mit andere ID\n11.remove(5)\nreturn max(11)\n\nliste_b = [1,2,3,4,5]\n\nprint (liste_b) # [1, 2, 3, 4, 5]\nprint (maxOhne5(liste_b)) #4\nprint (liste_b) # [1, 2, 3, 4, 5]\n\nPython MOOC - 2.2 Listen TOC 71/145\n\n[Image 72 OCR]\nZusammenfassung fur 2.2 Listen\nListen sind die Basis von allem:\n\n> Indexierung (Submengen auswahlen) ab 0, (slicing)\ngemischte Datentypen sind moglich\n\nlen(liste) , liste.pop(index) , in, not in\nliste.index(wert) , liste.remove (wert)\n\nliste.append(wert) , liste.insert(index, wert)\n\nlisteA + listeB, listeA.extend(listeB)\nliste.reverse() , liste.sort()\n\nliste.copy()\n\nveranderbare Objekte innerhalb einer Funktion andern, andert sie\n\nglobal\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.2 Listen TOC 72/145\n\n[Image 73 OCR]\n2. Objekte\n2.3 Dictionaries\n\nPython MOOC - 2.3 Dictionaries TOC 73/145\n\n[Image 74 OCR]\nDictionaries a\n\n> speichert Daten in Form Schliissel: Wert\n> optimiert, Werte schnell abzurufen, wenn der Schliissel bekannt ist\n\n> Schliissel sind einmalig, Datentyp der Werte ist egal\n\nNutzungsbeispiele:\n> Produktkatalog\n> Patienten IDs mit weiteren Informationen (kann Liste oder\nUnter-Dictionary sein)\n> HTTP-Statuscodes\n> Kontaktliste (Telefonbuch)\n> Warenkorb in Onlineshops\n\nPython MOOC - 2.3 Dictionaries TOC 74/ 145\n\n[Image 75 OCR]\nDictionaries\n\ndozent = {'Name': \"Berry\",\n\"Alter': 32}\n\nlen(dozent)\n\n## 2\n\ndozent['Name'] # Zugriff auf einen Eintrag\n## 'Berry'\n\ndozent['Alter'] = # Eintrag tiberschreiben\ndozent\n\n## {'Name': 'Berry', 'Alter': 33}\ndozent['Studis'] = # Eintrag hinzuftigen\n\ndozent\n## {'Name': 'Berry', 'Alter': 33, 'Studis': 42}\n\nPython MOOC - 2.3 Dictionaries\n\nTOC\n\n75/ 145\n\n[Image 76 OCR]\nNamenskonvention\n\nIch benutze ' Apostrophen in Dictionaries, da sie in f-strings mit\nAnfihrungszeichen benutzt werden kénnen. Doppelte und einfache Anftihrungszeichen konnen im F-string nicht\ngemischt werden. f\"Erstelle einen String mit {3+4} Berechnungen.\"\n## 'Erstelle einen String mit 7 Berechnungen. '\n\n£\"Hi {dozent['Name']}, du bist {dozent['Alter']} Jahre\nalt.\"\n## 'Hi Berry, du bist 33 Jahre alt.'\n\nSeit Python 3.12 (2023-10) ist das doch méglich.",
    "Python MOOC - 2.3 Dictionaries TOC 76/ 145\n\n[Image 77 OCR]\nZugriff auf Dictionaries\n\nfehlersichere Auswahl eines Schlissels:\ndozent.get('Name', \"Wert falls Schliissel fehlt\")\n## 'Berry'\n\ndozent.get('NAME', \"Wert falls Schliissel fehlt\")\n## ‘Wert falls Schltissel fehlt'\n\ndozent.keys() # Quasi eine Liste als Ausgabe\n\n## dict_keys(['Name', 'Alter', 'Studis'])\n\ndozent.values() # dozent.items() zum Iterieren\n## dict_values(['Berry', 33, 42])\n\n\"Alter\" in dozent.keys()\n## True\n\n\"Alter\" in dozent # ktirzer und schneller :)\n## True\n\nPython MOOC - 2.3 Dictionaries\n\nTOC\n\n77/145\n\n[Image 78 OCR]\nElemente aus einem Dictionary entfernen a\ndozent = {'Name':\"Berry\", 'Alter':32, 'Studis':42, 'z':0}\ndel(dozent['Alter']) # entfernt kompletten Eintrag\ndozent\n\n## {'Name': 'Berry', 'Studis': 42, 'z': O}\n\nstudis = dozent.pop('Studis')\n\nstudis\n\n## 42\n\ndozent\n\n## {'Name': 'Berry', 'z': 0}\n\ndozent.pop('Alter') # Schliissel nicht mehr da\n\n## KeyError: ’Alter’\n\ndozent.pop('Alter', None) # gibt None zuriick\n\ndozent.clear() # Alle Eintrage entfernen\ndozent\n\n## {}\n\nPython MOOC - 2.3 Dictionaries TOC 78/ 145\n\n[Image 79 OCR]\nDictionary: Zeiger (memory pointer) und Kopien\n\ndicti = {'a': 1, 'b': 2, 'c': 3}\n\ndict2 = dicti # dict2 ist nur ein Zeiger auf dictl\ndict3 = dict1. © # unabhdngige Kopie\n\nWenn man veradndert, andert sich auch\n\n(Das gilt fiir alle veranderbaren Objekte). dicti['c'] =\n\ndict2\n\n## {'a': 1, 'b': 2, 'c': 333}\n\ndict3\n\n## {'a': 1, 'b': 2, 'c': 3}\n\nPython MOOC - 2.3 Dictionaries TOC\n\n79/ 145\n\n[Image 80 OCR]\nDictionaries aktualisieren |\n\nPython MOOC - 2.3 Dictionaries TOC 80/ 145\n\n[Image 81 OCR]\nDictionary formatiert ausgeben\n\ndozent = {'Name': \"Berry\", 'Alter' : 32}\nfor k, v in dozent. QO:\nprint(\"Der Eintrag '\",k,\"' hat den Wert: \",v, sep=\"\")\n## Der Eintrag 'Name' hat den Wert: Berry\n## Der Eintrag 'Alter' hat den Wert: 32\n\nNachste Woche behandeln wir For-Schleifen :)\n\nPython MOOC - 2.3 Dictionaries TOC 81/ 145\n\n[Image 82 OCR]\nZusammenfassung fiir 2.3 Dictionaries\n\ndictionaries (Schliissel-Wert Paare):\n\ndict = {’Schluessel’:\"Wert\"}\ndict[’Schluessel’]\n\ndict.get(’Schluessel’, \"Ersatz\")\n\n*Schliissel’ in dict\n\ndict.pop(’Schluessel’, \"Ersatz\") , dict.clear()\n\ndict. copy()\n\nvvvrvvyy\n\ndictA.update(dictB)\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 2.3 Dictionaries TOC 82/ 145\n\n[Image 83 OCR]\n3.1 Bedingte Codeausfiihrung\n\n3. Schleifen\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung TOC 83/145\n\n[Image 84 OCR]\nVergleichende und logische Operatoren a\n\nvergleichende Operatoren:\nwert = 8\n\nB= D & C88 © gletad be 7 < wert < 9 # nice! a !=b # ungleich?",
    "## True\n\na<b # OaOaP als 7<8\n\na <= b # kleiner / gleich ng cman\n\na>b # grofer als maN ie \"Bn # alle\n\na >=b # gréfer / gleich \"a\" < \"pb\" # True\nwAN ge magn\n\nKommazahlen gerundet vergleichen:\n\n# zahl < GROB < klein\nsumme = 5.1 + 1.1\n\nsumme == 6.2 logische Operatoren:\n\nee Walla not False # NICHT\nround(summe,8) == round(6.2, 8) ## True\n\n## True True and 6 > 8 # UND\nimport math ## False\n\nmath. isclose(summe, 6.2) 9 > 8 or False # ODER\n## True ## True\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung, TOC 84/145\n\n[Image 85 OCR]\nAchtung vor bit-Operatoren\n\n7>1 & 6>1\n## False\n\n& ist ein Bit-Operator! (Nicht der UND-Operator wie in anderen Programmiersprachen)\n7>1 and 6>1\n\n## True\n\nDas gilt auch fiir das Zirkumflex (“):\n2°3 # ist eigentlich 8\n## 1\n\n* ist ein bindres XOR (ausschlieBliches ODER)\n\nsiehe stackoverflow / Was macht der Zirkumflex-Operator\n& fiihrt bitweise UND Operation auf Bits aus\n\nsiehe Wikipedia / Bitweise Operatoren\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung, TOC 85/145\n\n[Image 86 OCR]\nif b> a:\nprint(\"b ist gréfer\n## b ist groBer als a\n\nif b> a:\nprint(\"b ist\n\nelif a ==\nprint(\"a und\n\n## a und b sind\n\n100\n\nif b> a:\n\nprint(\"b ist\nelif a ==\n\nprint(\"a und\nelse:\n\nprint(\"a ist\n## a ist groBer\n\n\n[Image 87 OCR]\nBedingte Codeausftihrung: Bedingungen kombinieren\n\na= >; be=\nif a>b and (b== or b==30):\n\nprint(\"a ist gré®er und b ist 20 oder 30\")\n## a ist groBer und b ist 20 oder 30\n\ncond = [True, False, True, True, True]\n(cond) # alle wahr? ## False\n(cond) # mindestens 1 wahr? ## True\n(cond) # Anzahl wahr\n\n#H# 4\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung TOC\n\n87/ 145\n\n[Image 88 OCR]\nBedingte Codeausfthrung in einer Funktion: Ubersicht a\n\nFiir eine Vierfeldertafel gibt es zwei Ansatze cond 2\nTrue False\n%& Tre! tt tF\nc\n. 8 False} Ft FF\nmit return , verschachtelt, ohne elif : =\nif condi:\nif cond2: return \"tt\" # Zeilenumbriiche vor return\nelse: return \"tF\" # aus Platzgrtinden\nif cond2: return \"Ft\" # weggelassen. In echt bitte\nelse: return \"FF\" # setzen ftir den style guide\n\nmit print, eine Ebene, mit and + elif:\n\nif cond1 and cond2: print(\"tt\")\nelif condi: print(\"tF\")\n\nelif cond2: print(\"Ft\")\n\nelse: print(\"FF\")\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung, TOC 88/145\n\n[Image 89 OCR]\nBedingte Codeausftthrung - Mathe-Beispiel |\nant Ogee\n\n~— a\n2 on\nLibs) = Jr-2Wlw-—), 5 SS\n\nI\nmm ee Quelle mit n=1 & ‘inf, als Grenzen:\n2x wenn x < 0.5 ‘\nf(x) = 1-2(x-0.5) wenn 0.5 <= x<=1 ° f(x)\n0 wenn x > 1 .",
    "7 7\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung\n\nTOC 89/ 145\n\n[Image 90 OCR]\nBedingte Codeausftihrung - input-Beispiel\n\nusername = ('Gib deinen Nutzernamen ein: ')\npassword ('Gib dein Passwort ein: ')\n\nGib Login erfolgreich aus fiir den Nutzer admin mit Passwort\n\n123456, sonst Nutzername oder Passwort sind falsch\n\nif username == ‘admin' and password == '123456':\nprint('Login erfolgreich')\nelse:\n\nprint ('Nutzername oder Passwort sind falsch')\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung TOC 90/ 145\n\n[Image 91 OCR]\nBedingte Codeausfiihrung - Schaltjahr-Beispiel a\n\nEin Schaltjahr ist ein Kalenderjahr, das einen zusatzlichen Tag (29. Februar) enthalt, um im Gleichschritt mit dem astrononomischen Jahr zu\nbleiben. Diese zusatzlichen Tage treten in jedem Jahr auf, welches ein\nVielfaches von 4 ist, auBer den Jahren, welche Vielfache von 100 sind, es\nsei denn, sie sind auch durch 400 teilbar. Finde heraus, ob ein Jahr ein Schaltjahr ist. Der Modulo-Operator ist % . Das Jahr sollte durch 4 teilbar sein und (nicht teilbar durch 100 oder\nteilbar durch 400)\n\njahr = int(input('Gib das Jahr ein: '))\n\nist_schalt = jahr7#4==0 and jahrZ100!=0 or jahr%400==0\nprint (ist_schalt)\n\nPython MOOC - 3.1 Bedingte Codeausfiihrung, TOC 91/145\n\n[Image 92 OCR]\nZusammenfassung fiir 3.1 Bedingte Codeausfuhrung wa\nLogik und Bedingte Codeausfiihrung:\n\n> Vergleichsoperatoren, min < value < max, not, and, or\n\n> & und ~ sind bitweise Operatoren, nicht verwenden (auBer das ist\nbeabsichtigt)\n\n> Struktur bedingten Codes:\nif bedingung1:\nausdruck1\nelif bedingung2:\nausdruck2\nelse:\nausdruck3\n\n> all, any, sum\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.1 Bedingte Codeausfiihrung, TOC 92/145\n\n[Image 93 OCR]\n3.2 For- und While-Schleifen\n3.",
    "Schleifen\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 93/ 145\n\n[Image 94 OCR]\nSchleifen: Anweisungen wiederholen\n\nCode mehrfach ausfiihren, jeweils mit einem anderen Wert\n\nNachfolgender Code hat viele Dopplungen:\nprint (list (range(1,4)))\nprint (list (range(1,5)))\nprint (list (range(1,9)))\n\nDas geht einfacher mit einer Schleife:\nfor ende in [4,5,9]:\n\nprint (list (range(1,ende)))\n## [1, 2, 3]\n## [1, 2, 3, 4]\n## [1, 2, 3, 4, 5, 6, 7, 8]\n\nPython MOOC - 3.2 For- und While-Schleifen\n\nTOC 94/145\n\n[Image 95 OCR]\nSchleifenstruktur\n\nfor variable in werte_liste :\nmach_etwas_mit (variable)\n\n# Doppelpunkt (:) wird bendtigt\n\n# Einrtickung ist wichtig\n\nwhile bedingung_erfuellt:\nfuehre_dinge_aus_die_ggf_die_bedingung_aendern()\nif diesmal_fertig:\ncontinue # springe zur ndchsten Iteration\nif ganz_fertig:\nbreak # brich die Schleife ab\nnur_ausfuehren_wenn_beide_FERTIGs_falsch_sind()\n\nKonvention fiir eine nicht verwendete Indexvariable:\nfor _ in range(3):\n\nprint(\"kram\") # -> kram kram kram\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 95/ 145\n\n[Image 96 OCR]\nfor-loop print-Beispiel 1\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 96/ 145\n\n[Image 97 OCR]\nfor-loop print-Beispiel 2\n\nZeige alle Objektnamen eines Moduls auf einer jeweils eigenen Zeile an:\n\nimport math # eingebautes Modul (Paket)\nfor f in dir(math):\nprint (f)\n## __doc__\nHH... # manuell ausgewahlte Ausgabe\n## __name__\n## __package__\n## acos\n## ceil\n## exp\n## factorial\n## gamma\n## inf\n## isnan\n## log10\n## pi\n## pow\n## sin\n## sqrt\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 97/145\n\n[Image 98 OCR]\nfor-Schleife Maximum-Beispiel\n\nwerte = [923,790,447 ,617,534,93,895,60,21,\n962,992,302,435,902,795,482]\n\nStell dir vor, die Funktion max ware nicht verfiigbar. Bestimme den groBten Wert mithilfe einer Schleife. maxi = 0\nfor w in werte:\n\nif w > maxi:\n\nmaxi = w\n\nprint (maxi)\n## 992\n\nPython MOOC - 3.2 For- und While-Schleifen TOC\n\n98/ 145\n\n[Image 99 OCR]\nfor-loop Auswahl-Beispiel |\n\nWahle alle geraden Zahlen aus einer Liste aus.",
    "Python MOOC - 3.2 For- und While-Schleifen TOC 99/ 145\n\n[Image 100 OCR]\nMehrere Iteratoren\n\nMehrere Objekte in einer Codezeile (siehe 2.1 Objekttypen)\nfor a,b in [(1,11), (2,22), (3,33), (4,44)]:\n\nprint(\"a:\", a, \" b:\", b, \"-> Ergebnis:\", b-2*a)\n## a: 1 b: 11 -> Ergebnis: 9\n\n## a: 2 b: 22 -> Ergebnis: 18\n## a: 3  b: 33 -> Ergebnis: 27\n## a: 4 b: 44 -> Ergebnis: 36\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 100/ 145\n\n[Image 101 OCR]\nwhile-loop print-Beispiel\n\nSo lange das usreicht, Sachen kaufen (und Restbetrag anzeigen)\n8\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 101/ 145\n\n[Image 102 OCR]\nwhile-loop input-Beispiel a\nwiederholt eine Zahl per input abfragen, bis sie korrekt erraten wurde\nzahl = 0\nwhile zahl != 42 :\n\nzahl = input(\"Rate eine Zahl: \")\n\nzahl = int(zahl)\n\nif zahl==42:\nprint(\"Du hast die Antwort (auf alles) gefunden.\")\nelif zahl > 42: # print(..., flush=True) in Rstudio\nprint(f\"Tut mir leid, {zahl} ist zu gro8.\")\nelse:\n\nprint(f\"Tut mir leid, {zahl} ist zu klein.\")\n## Rate eine Zahl: 78\n## Tut mir leid, 78 ist zu grof. ## Rate eine Zahl: 31\n## Tut mir leid, 31 ist zu klein. ## Rate eine Zahl: 42\n\n## Du hast die Antwort (auf alles) gefunden. Python MOOC - 3.2 For- und While-Schleifen TOC 102/ 145\n\n[Image 103 OCR]\nwhile-loop input-Alternative a\n\nwhile(True):\n\nzahl = (\"Rate eine Zahl: \")\n\nzahl = (zahl)\n\nif zahl==\nprint(\"Du hast die Antwort (auf alles) gefunden.\")\nbreak\n\nelif zahl >\nprint(f\"Tut mir leid, {zahl} ist zu gro8.\")\n\nelise:\nprint(f\"Tut mir leid, {zahl} ist zu klein.\")\n\nbeginnt eine Schleife, die manuell beendet werden muss\n(mittels , in einer Funktion geht auch )\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 103/145\n\n[Image 104 OCR]\nSchleifensteuerung (control commands) Beispiele a\n\nfor buchstabe in ‘Python': # strings sind iterierbar :)\n\nif buchstabe == ‘h':\ncontinue # tberspringe den Rest einer Ausftihrung\n\nprint(\"Aktuell: \" + buchstabe)\n\n## Aktuell: P\n\n## Aktuell: y\n\n## Aktuell: t\n\n## Aktuell: o\n\n## Aktuell: n\n\nfor buchstabe in 'Python':\nif buchstabe == ‘h':\nbreak # die Schleife vollstdndig abbrechen\nprint(\"Aktuell: \" + buchstabe)\n## Aktuell: P\n## Aktuell: y\n## Aktuell: t\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 104/ 145\n\n[Image 105 OCR]\nAbbildung (mapping)\n\nbuchstabenliste = [\"abcdef\", \"ab\", \"abc\"]\n\nbuchstabenlaenge = []\n\nfor b in buchstabenliste:\nbuchstabenlaenge.",
    "append (len(b) )\n\nbuchstabenlaenge\n\n## [6, 2, 3]\n\nb_laenge = map(len, buchstabenliste)\nb_laenge\n\n## <map object at 0x000001E51057F760>\nlist (b_laenge)\n\n## [6, 2, 3]\n\nlist(map(len, buchstabenliste) )\n\n# ist viel ktirzer als die Schleife oben ED)\n\nPython MOOC - 3.2 For- und While-Schleifen\n\nTOC\n\n105/ 145\n\n[Image 106 OCR]\nObjekte in Schleifen andern 1 a\nids = [\"at\",\"bi\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\", \"C1\", \"dt\"]\n# Entferne Werte, die mit b starten\nfor v in ids:\nif v[0]==\"b\": ids.remove(v)\nids\n## ['al', 'b2', 'b4', 'b6', 'ci', 'di']\nWarum ist die Halfte der b’s noch drin? Nach der zweiten Iteration ist ids ai, b2, b3, b4, b5, b6, ci, di,\nweil \"b1” entfernt wurde. In der dritten Iteration wertet Python ’ids’\nwieder aus und gibt das dritte Element an v (\"b3\"). Dieses wird\n\nwieder entfernt, also verbleiben ai, b2, b4, b5, b6, c1, di. Das\n\nwiederholt sich, bis wir bei ai, b2, b4, b6, ci, di ankommen. Ein\nIndex hilft nicht: for i in range(len(ids)) gibt einen IndexError. Wie konnen wir korrekt in einer Schleife die Werte auswahlen, die nicht\n\nmit b beginnen? Python MOOC - 3.2 For- und While-Schleifen TOC 106/ 145\n\n[Image 107 OCR]\nObjekte in Schleifen andern 2\n\nids = [\"al\",\"bi\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\", \"ct\", \"d1\"J\nausgabe = []\nfor v in ids:\nif v[0]!=\"b\": ausgabe.append(v)\nprint (ausgabe)\n## ['al', 'ci', 'di']\nDas Iteratorobjekt in einer Schleife darf nicht verandert werden! Unerwartete Dinge: Iteration in Python\nEs gibt hier eine Alternative, die (scheinbar) ohne Schleife auskommt:\n\ndef beginnt_nicht_mit_b(x):\n\nreturn x[0]!=\"b\"\nlist (filter (beginnt_nicht_mit_b, ids))\n## ['al', 'c1', 'd1']\nlist (filter(lambda x : x[0]!=\"b\", ids))\n## ['al', 'c1', 'd1']\n\nPython MOOC - 3.2 For- und While-Schleifen TOC 107/ 145\n\n[Image 108 OCR]\nZusammenfassung fiir 3.2 For- und While-Schleifen\n\nfor- und while-Schleifen :\n> Schleifenstruktur:\n\nfor var in liste:\nausdruck (var)\n\ncontinue , break\n\nfor _ in range(n): fur ungenutzte Variable\nfor x,y in [(xl,y1),(x2,y2)]:\n\nlist (map(funktion, liste))\n\nlist (filter(funktion, liste))\n\nVerandere nicht das Iterator-Objekt wahrend Iteration\n\nvvvvvyeyvVyY\n\nIm echten Leben: map/filter, list comprehension, pandas\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.2 For- und While-Schleifen TOC\n\n108/ 145\n\n[Image 109 OCR]\n3. Schleifen 3.3 List comprehension\n\nPython MOOC - 3.3 List comprehension TOC 109/ 145\n\n[Image 110 OCR]\nList comprehension (Codelange verringern) - Beispiel 1\n\ndef tu_etwas_mit (x):\nreturn x + 5\neinige_zahlen = [6, 9, 17, -2, 24]\n\nergebnis = []\n\nfor zahl in einige_zahlen:\nneue_zahl = tu_etwas_mit(zahl)\nergebnis.",
    "append (neue_zahl)\n\nergebnis\n\n## [11, 14, 22, 3, 29]\n\nergebnis = [tu_etwas_mit(zahl) for zahl in einige_zahlen]\n\nergebnis\n## [11, 14, 22, 3, 29]\n\nlist (map(tu_etwas_mit, einige_zahlen) )\n\n## [11, 14, 22, 3, 29]\n\nPython MOOC - 3.3 List comprehension\n\n[Image 111 OCR]\nList comprehension (Codelange verringern) - Beispiel 2\n\nnamen = [\"Alex\",\"Berry\",\"Beth\",\"Chris\",\"Dave\"]\n\nmitB = []\nfor wort in namen:\nif wort[0] == \"B\":\nmitB. (wort)\nmitB\n## ['Berry', 'Beth']\n\nmitB = [wort for wort in namen if wort[0] == \"B\"]\nmitB\n## ['Berry', 'Beth']\n\nPython MOOC - 3.3 List comprehension TOC\n\n111/145\n\n[Image 112 OCR]\nDictionary comprehension funktioniert auch so\n\n# Gib die Buchstabenzahl jedes Wortes aus:\n\nnachricht = \"du steigerst dich\"\n\n{wort:len(wort) for wort in nachricht.split()}\n\n## {'du': 2, 'steigerst': 9, 'dich': 4}\n\n# Verdopple jeden Wert im Dictionary:\n\ndicti = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, '£':6}\ndoppel_dicti = {k:v*2 for (k,v) in dict1.items()}\n\n# Wahle alle geraden Eintrdge, die grofer als 2 sind:\n{k:v for (k,v) in dictl.items() if v>2 and v%2==0}\n## {'d': 4, 'f': 6}\n\n# Wandle von Grad Fahrenheit nach Celcius um:\naF = {'ti': -30, 't2': -20, 't3': -10, 't4': Oo}\n\ndC = {k:5/9*float(v-32) for (k,v) in dF.items()}\ndC = {k+\"C\":round(v) for (k,v) in dC.items()}\ndc\n\n## {'t1C': -34, 't2C': -29, 't3C': -23, 't4C': -18}\n\nPython MOOC - 3.3 List comprehension TOC 112/145\n\n[Image 113 OCR]\nList comprehension Ubung a\n\nKiirze alle drei Schleifen auf eine einzelne Codezeile. werte = [11,10,2,3,15,3,5,7,7,2,8,7,5,6,5,8,5,9,6,3,15,6,9]\nquadratsumme = 0\nfor v in werte:\nquadratsumme += v**2\nquadratsumme\n## 1351\n\nzahlen = [951,402,984,651,360,69,408,319,601,485,980,507,725,\n547 ,544,615,83,165,141,501,263,617,865,575,219,390,984,592,236,\n105 942,941,386 ,462,47,418,907,344]\ngerade_zahlen = []\nfor n in zahlen:\nif n42==0: gerade_zahlen.append(n)\ngerade_zahlen\n## (402, 984, 360, 408, 980, 544, 390, 984, 592, 236, 942, 386, 462, 418, 344]\n\nimport random\nmax_exp = []\nfor i in range(50):\nmax_exp.",
    "append (random.expovariate(0.2))\nmax_exp = max(max_exp)\nmax_exp\n## 20.343037401675073\n\nPython MOOC - 3.3 List comprehension TOC 113/145\n\n[Image 114 OCR]\nList comprehension Ubungslésungen |\n\nwerte = [11,10,2,3,15,3,5,7,7,2,8,7,5,6,5,8,5,9,6,3,15,6,9]\nsum([v**2 for v in werte])\n## 1351\n\nzahlen = [951,402,984,651,360,69,408,319,601,485,980,507,725,\n\n547 ,544,615,83,165,141,501,263,617,865,575,219, 390,984,592, 236,\n\n105, 942,941,386, 462,47,418,907,344]\n\n[n for n in zahlen if n%2==0]\n\n## [402, 984, 360, 408, 980, 544, 390, 984, 592, 236, 942, 386, 462, 418, 344]\n\nimport random\nmax ([random. (0.2) for _ in range(50)])\n## 19.221103122473906\n\nPython MOOC - 3.3 List comprehension TOC 114/145\n\n[Image 115 OCR]\nZusammenfassung fiir 3.3 List comprehension\n\nSchleifen-code deutlich verkiirzen:\n\n> Listen- und Dict comprehension\n> [tu_etwas_mit(x) for x in liste if bedingung(x)]\n\n> {k:tu_etwasmit(v) for (k,v) in eine_dict.items()}\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 3.3 List comprehension TOC 115/ 145\n\n[Image 116 OCR]\n4.1 Fehlermanagement\n\n4. Programmieren\n\nPython MOOC - 4.1 Fehlermanagement TOC 116/145\n\n[Image 117 OCR]\nFehlermanagement: try - except\n\nBei einem Fehler bricht die komplette Programmausfiihrung ab. Beispiel: TypeError: falscher Datentyp fiir Operator oder Funktion\n\nergebnis_einer_berechnung = '2\"\n\n7 + ergebnis_einer_berechnung\n## TypeError: unsupported operand type(s) for +: ’int’\nand ’str’\n\nPython kann Code aber auch probeweise ausfiihren, und im Fall eines\nFehlers was anderes machen als abbrechen. try:\n7 + ergebnis_einer_berechnung\nexcept TypeError:\nprint(\"Zeichenkette und Nummer gemischt\")\n## Zeichenkette und Nummer gemischt\n\nBeachte die Einriickung, wie mit allen Python Kontrollstrukturen\n\nPython MOOC - 4.1 Fehlermanagement TOC 117/145\n\n[Image 118 OCR]\ngenerisches except |\n\ntry\n\nexcept TypeError\n\nprint\nexcept\nprint\n\nPython MOOC - 4.1 Fehlermanagement TOC 118/145\n\n[Image 119 OCR]\nce L\n\ntry:\n\n7 + \"2\" # Code mit mdglichen Fehlern\nexcept:\n\nprint(\"Code fehlgeschlagen\")\nelse:\n\nprint(\"Code erfolgreich ausgefiihrt\")\n## Code fehlgeschlagen\n\nDer else Code wird ausgefiihrt, wenn keine Fehler auftreten. Konnte\n\nauch im try Teil sein, man sollte aber den potentiellen Fehler und den\nUmgang damit nah beieinander behalten. Fange nur erwartete Fehler ab\n(andere Fehler sollten weiterhin auftreten). else wird vor finally ausgefiihrt (nachste Folie). Python MOOC - 4.1 Fehlermanagement TOC 119/145\n\n[Image 120 OCR]\nfinally a\n\ntry:\n+ \"2\" # Code mit médglichen Fehlern\nexcept:\nprint(\"Code fehlgeschlagen\")\nfinally:\n\nprint(\"Programm fertig\")\n## Code fehlgeschlagen\n## Programm fertig\n\nCode in wird ausgefuhrt, selbst wenn return / break / continue\naufgerufen wird oder ein anderer (nicht abgefangener) Fehler auftritt.",
    "Python MOOC - 4.1 Fehlermanagement TOC 120/145\n\n[Image 121 OCR]\ntraceback\n\ntraceback gibt aus, woher der Fehler kommt:\n\nimport traceback\ntry:\n7 + nichtExistierendesObjekt\nexcept:\nprint(\"Fehler aufgetreten:\",traceback.format_exc())\n## Fehler aufgetreten: Traceback (most recent call last):\n## File \"<string>\", line 2, in <module> ## NameError:\nname ’nichtExistierendesObjekt’ is not defined\n\ninformativer in echter Anwendung (Folienstruktur kann kein traceback). IDEs mit Debugger stellen oft tracebacks fiir Fehler zur Verfiigung\n\nPython MOOC - 4.1 Fehlermanagement TOC 121/145\n\n[Image 122 OCR]\nException Objekt a\n\nFehler mit benutzerdefiniertem Prafix protokollieren\n\ndef addiere7_mit_print_statt_fehler(x):\ntry:\nreturn x + 7\nexcept Exception as e: # Fehlermeldung als Variable\nprint(\"Ein Fehler ist aufgetreten:\",e, sep=\"\\n\")\n\ntol\n\n€\n\naddiere7_mit_print_statt_fehler (3)\n\n## 10\n\naddiere7_mit_print_statt_fehler(\"3\")\n\n## Ein Fehler ist aufgetreten:\n\n## can only concatenate str (mot \"int\") to str\naddiere7_mit_print_statt_fehler (None)\n\n## Ein Fehler ist aufgetreten:\n\n## unsupported operand type(s) for +: 'NoneType' and 'int'\n\nPython MOOC - 4.1 Fehlermanagement TOC 122/145\n\n[Image 123 OCR]\nException info a\n\ndef fehler_mit_ganzer_nachricht(x): # stiehe auch\ntry: # sys.exc_info(Q)\nx+7\nexcept Exception as e:\nprint(f\"Ein {type(e).__name__} ist passiert:\\n{e}\")\n\nfehler_mit_ganzer_nachricht (3)\n\nfehler_mit_ganzer_nachricht (None)\n\n## Ein TypeError ist passiert:\n\n## unsupported operand type(s) for +: 'NoneType' and 'int'\nfehler_mit_ganzer_nachricht (\"3\")\n\n## Ein TypeError ist passiert:\n\n## can only concatenate str (mot \"int\") to str\nfehler_mit_ganzer_nachricht (dummyvar)\n\n## NameError: name ’dummyvar’ is not defined\n\nPython MOOC - 4.1 Fehlermanagement TOC 123/145\n\n[Image 124 OCR]\nZeitstempel a\n\nNachrichten mit Zeitstempel, niitzlich fiir Logging (protokollieren)\nimport time\njetzt = time.strftime(\"%Y-%m-hd YH: .M UTC\", time.gmtime())\nprint (jetzt)\n## 2024-10-15 08:25 UTC\ndef fehler_mit_zeitstempel (x):\ntry:\nx +7\nexcept:\nn = time.strftime(\"/%Y-%m-%d YH: %M UTC\", time. gmtime())\nprint(\"Ein Fehler ist aufgetreten am:\", n)\n\nfehler_mit_zeitstempel (3)\n\nfehler_mit_zeitstempel (None)\n## Ein Fehler ist aufgetreten am: 2024-10-15 08:25 UTC\n\nPython MOOC - 4.1 Fehlermanagement TOC 124/145\n\n[Image 125 OCR]\nFehlermanagement Beispiel\n\nNone\nwhile not\ntry\n\nexcept ValueError\nprint\nprint\n\nPython MOOC - 4.1 Fehlermanagement\n\nTOC\n\n125/ 145\n\n[Image 126 OCR]\nZusammenfassung fur 4.1 Fehlermanagement\nExceptions abfangen und verwalten:\n> Struktur\n\ntry:\ncode_mit_moeglichen_Fehlern\nexcept BestimmterError: # mdglichst nur konkrete\nwas_jetzt_zu_tun_ist # Fehler abfangen! except Exception as e:\nmach_etwas_damit(e) # z.B. Logging\ntraceback. format_exc()\ntime.strftime(\"/Y-/m-%d %H:%M UTC\", time.gmtime())\n\nexcept: # falls Excpetion as e\nandere_Fehler_behandeln # nicht genutzt wurde\nelse:\n\nwas_zu_tun_ist_falls_BestimmterError_nicht_passiert\nfinally:\ntu_das_immer_am_Ende\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard.",
    "Python MOOC - 4.1 Fehlermanagement TOC 126/ 145\n\n[Image 127 OCR]\n4.2 Eigene Klassen schreiben\n\n4. Programmieren\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 127/145\n\n[Image 128 OCR]\nBenutzerdefinierte Klassen a\n\nEin paar Definitionen:\n\nObjekt: Sammlung von Daten (Variablen) und Methoden (Funktionen)\ndie auf Basis dieser Daten operieren. (Attribute + Verhalten)\n\nKlasse: Vorlage fiir Objekte\n\nInstanz: spezifisches Objekt einer Klasse\n\nclass Person:\npass\n\nPython verbietet leere Kérper in Klassen. Das pass Statement dient als\nPlatzhalter fur Code\n\npi = Person() # erstellt Instanz der Klasse Person\n\npi.name = \"Berry\" ; pl.alter = 32 # Attribute hinzuftigen\n\npi\n\n## <__main__.Person object at 0x000001EFDO4EB9D0>\npi._.dict__ # Dictionary mit allen Attributen\n\n## {'name': 'Berry', ‘alter': 32}\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 128/145\n\n[Image 129 OCR]\nBenutzerdefinierte Klasse definieren a\n\nclass Person:\ndef __init__(self, name, alter):\nself.name = name\nself.alter = alter\n\npersoni = Person('Berry', 23) # konstrutert neue Person\nperson2 Person('Christina', 16)\n\nperson1.name\n\n## 'Berry'\n\n_-init__: spezielle Funktion die beim Erstellen des Objekts aufgerufen\nwird und die Attribute initialisiert. Sie wirkt wie ein Konstruktor. self: steht fiir die Instanz der Klasse, mit der wir die Methode aufrufen. Es ist das erste Argument von Methoden wie _init__. Objekte personi und person2 haben eigene Attribute (name, alter). Mit dem self Argument konnen die Methoden auf Attribute der\nspezifischen Instanz zugreifen. Python MOOC - 4.2 Eigene Klassen schreiben TOC 129/145\n\n[Image 130 OCR]\nMethoden einer benutzerdefinierten Klasse a\n\neine Methode, die iiberpriift ob eine Person Horrorfilme schauen darf:\nclass Person:\ndef __init__(self, name, alter):\nself.name = name\nself.alter = alter\n\ndef darf_horrorfilm_sehen(self): # diese Funktion\n\nif self.alter >= 18: # ist eine Methode\nreturn \"los gehts!\" # fiir alle Objekte\nelse: # der Klasse ‘Person‘\n\nreturn \"sorry, zu jung\"\n\npersoni = Person('Berry', 23)\npersoni.darf_horrorfilm_sehen()\n## ‘los gehts!'\n\nperson2 = Person('Christina', 16)\nperson2.darf_horrorfilm_sehen()\n## ‘sorry, zu jung'\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 130/145\n\n[Image 131 OCR]\nUbung und Ressourcen a\n\nWie kann man die Methode darf_horrorfilm_sehen vereinfachen,\nsodass sie True / False zurtickgibt?",
    "def darf_horrorfilm_sehen(self):\nreturn self.alter >= 18\n\nWeiterftihrende Materialien:\nDr Philip Yip\n\nPython101\n\nPynative\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 131/ 145\n\n[Image 132 OCR]\nKlasse mit Eingabetberpriifung\n\nclass Patient:\ndef __init__(self, pid, geschlecht, BD):\nself.pid = pid\nself.geschlecht = geschlecht\nself.BD = BD\nif geschlecht not in [\"m\",\"w\",\"d\"]:\nraise ValueError(\"geschlecht muss m/w/d sein\")\ndef hat_bluthochdruck(self):\nreturn self.BD > 130\n\nPatient (pid=\"Pat456\", geschlecht=\"Divers\", BD=120)\n## ValueError: geschlecht muss m/w/d sein\n\narmer_kerl = Patient(\"Pati23\", \"m\", 113)\narmer_kerl.BD = 150\n\nprint(\"jetzt behandeln:\", armer_kerl.hat_bluthochdruck())\n## jetzt behandeln: True\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 132/145\n\n[Image 133 OCR]\nKlassenvariablen, siehe z.B. ionos.de a\n\nclass Student:\nanzahl = 0 # Klassenvariable\ndef __init__(self, name):\nself.name = name\nStudent.anzahl += 1 # bez jeder Erstellung + 1\n\nsi Student (\"Anna Lena\")\ns2 Student (\"Christina\")\nStudent (\"Berry\")\n\nStudent .anzahl\n## 3\n\ns2.anzahl # Instanzvariable greift auf Klassenvariable zu\n## 3\ns2.anzahl = 1000\n\nStudent.anzahl # unabhdngig einer einzelnen Instanz\n## 3\n\nPython MOOC - 4.2 Eigene Klassen schreiben TOC 133/145\n\n[Image 134 OCR]\nKlassen (Aufgabe + Teillésung) a\n\nHerons Formel ergibt die Flache eines Dreiecks, wenn die Lange aller drei\nSeiten bekannt ist. Eine Seite eines Dreiecks kann nicht langer sein als\ndie Summe der beiden Anderen. Schreibe Code, der die Flache ausgibt -\noder ” Kein Dreieck”, wenn eine Seite zu lang ist. halbperimeter s = (at+b+c)/2  flaeche a = sqrt(s(s-a)(s-b)(s-c))\n\na = 10\nb=4\nc=5\n\nif atb > c and atc > b and btec >a:\ns = (atb+c)/2\nflaeche = (s*(s-a)*(s-b)*(s-c))**0.5 #**0.5 = sqrt\nf\"Flaeche des Dreiecks: {flaeche}\"\nelse:\n\"Kein Dreieck\"\n\nSchreibe eine Dreieck Klasse, die einen Fehler fiir ungiiltige Dreiecke\nerzeugt und eine Flachenmethode hat.",
    "Python MOOC - 4.2 Eigene Klassen schreiben TOC 134/145\n\n[Image 135 OCR]\nKlassen Aufgaben (Lésung)\n\nclass Dreieck:\ndef __init__(self, a, b, c):\nself.a=a\nself.b b\nself.c ©\nif not(atb > c and atc > b and btc >a):\n\nraise ValueError('ungiiltig: zu lange Seite')\n\ndef flaeche(self):\np = (self.atself.btself.c)/2\n\nflaeche = (p*(p-self.a)*(p-self.b)*(p-self.c))**0.5\n\nreturn flaeche\n\neck = Dreieck(a=3, b=4, c=5)\neck.__dict__ # Attribute ausgeben\n## {'a': 3, 'b': 4, 'c': 5}\neck.flaeche()\n\n## 6.0\n\nPython MOOC - 4.2 Eigene Klassen schreiben Toc\n\n135/ 145\n\n[Image 136 OCR]\nZusammenfassung fur 4.2 Eigene Klassen schreiben\n\nBenutzerdefinierte Klassen:\n\n> generelle Struktur:\nclass MeineKlasse:\nclassVariable = “wert”\ndef __init__(self, args):\nself.args = args\nif not gueltig(args): raise SomeError(\"info\")\ndef eineMethode(self):\nreturn self.args\n\neineInstanz = MeineKlasse(\"werte\")\neineInstanz.eineMethode()\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 4.2 Eigene Klassen schreiben Toc\n\n136/ 145\n\n[Image 137 OCR]\n4.3 Unit Tests\n\n4. Programmieren\n\nPython MOOC - 4.3 Unit Tests TOC 137/145\n\n[Image 138 OCR]\nWarum Testen? a\n\n> Beim Programmieren konnen unbemerkt Fehler entstehen und sich\nim Code manifestieren. > Diese Fehler konnen zu unerwartetem Verhalten oder gar einem\nProgrammabbruch fihren. > Manuelles Ausprobieren aller moglichen Falle wird zunehmend\naufwandig und unibersichtlich. > Daher: automatisiertes Testen\n\nPython MOOC - 4.3 Unit Tests TOC 138/ 145\n\n[Image 139 OCR]\nTestverfahren\n\n> Statische Testverfahren (= ohne Codeausfiihrung)\nP Code-Reviews (durch Kolleg:innen, neuerdings durch Kl)\n> Quellcodeanalyse (z.B. PyLint)\ndef addiere(a, b):\nsumme = a + b\nreturn a + b\n\n## warning (W0612, unused-variable, addiere) Unused\nvariable ’summe’\n\n> Dynamische Testverfahren (= mit Codeausfilhrung)\n> Unit Tests (z.B. mit PyUnit)\n> Integration Tests (z.B. mit PyUnit)\nPm System Tests (z.B. Selenium fiir Webanwendungen)\n> Acceptance Tests (z.B. Selenium, Robot Framework)\n\nPython MOOC - 4.3 Unit Tests TOC 139/ 145\n\n[Image 140 OCR]\nBeispiel - \"zuletzt gesehen” a\n\nEine Chatanwendung soll anzeigen, wann eine Person zuletzt online war. Die Anzeige soll in Minuten / Stunden / Tagen erfolgen.",
    "Skript onlinestatus.py mit folgender naiver Umsetzung:\n\ndef (sek):\nif sek == 0:\nreturn \"Online\"\nelif sek < 60:\nreturn \"Zuletzt vor weniger als 1 Minute gesehen\"\nelif sek < 60*60:\nreturn f\"Zuletzt vor {sek // 60} Minuten gesehen\"\nelif sek < 60*60*24:\nreturn f\"Zuletzt vor {sek // (60*60)} Stunden gesehen\"\nelse:\nreturn f\"Zuletzt vor {sek // (60*60*24)} Tagen gesehen\"\n\nPython MOOC - 4.3 Unit Tests TOC 140/ 145\n\n[Image 141 OCR]\nUnit Test — \"zuletzt gesehen” a\nSkript test_onlinestatus.py mit:\nimport unittest\nfrom onlinestatus import zuletzt_gesehen\nclass ZuletztGesehenTest (unittest .TestCase) :\ndef test_online(self):\ntatsaechlich = zuletzt_gesehen(0)\n\nerwartet = \"Online\"\nself.assertEqual(tatsaechlich, erwartet)\nTest ausfiihren - Option 1: Am Ende von test_onlinestatus. py :\n\nif __name__ == \"__main__\": unittest.main()\n\nTest ausfiihren - Option 2: leichter automatisierbar\n\npython -m unittest test_onlinestatus.py # Mac: python3\n\n2 shen\n## Ran 1 test in 0.000s\n\n## OK\n\nPython MOOC - 4.3 Unit Tests TOC 141/145\n\n[Image 142 OCR]\nMehr Tests! import unittest\nfrom onlinestatus import zuletzt_gesehen\nclass ZuletztGesehenTest (unittest .TestCase) :\ndef test_online(self):\nself.assertEqual(zuletzt_gesehen(0), \"Online\")\ndef test_eine_sekunde(self):\nself .assertEqual (zuletzt_gesehen(1),\n\"Zuletzt vor weniger als 1 Minute gesehen\")\n\ndef test_weniger_als_eine_minute(self):\nself .assertEqual (zuletzt_gesehen(59) ,\n\"Zuletzt vor weniger als 1 Minute gesehen\")\ndef test_eine_minute(self):\nself .assertEqual (zuletzt_gesehen(60),\n\"Zuletzt vor 1 Minute gesehen\")\ndef test_weniger_als_zwei_minuten(self):\nself .assertEqual (zuletzt_gesehen(119) ,\n\"Zuletzt vor 1 Minute gesehen\")\ndef test_zwei_minuten(self):\nself .assertEqual (zuletzt_gesehen(120) ,\n\"Zuletzt vor 2 Minuten gesehen\")\n\nPython MOOC - 4.3 Unit Tests TOC 142/145\n\n[Image 143 OCR]\nTestergebnis interpretieren\n\npython -m unittest test_onlinestatus.py\n\n## F...F. ##\n\n##\n\n##\n\n## Traceback (most recent call last):\n\nHt File \"test_onlinestatus.py\", line 11, in test_eine_minute\n\nHt self .assertEqual (zuletzt_gesehen(60), \"Zuletzt vor 1 Minute gesehen\")\n## AssertionError: ’Zuletzt vor 1 Minuten gesehen’ !=\n\n?Zuletzt vor 1 Minute gesehen’\n\n## - Zuletzt vor 1 Minuten gesehen\n#H ? -\n\n## + Zuletzt vor 1 Minute gesehen\n##\n\n## [22]\n\n##\n##\n## Ran 6 tests in 0.001s\n##\n\n## FAILED (failures=2)\n\nPython MOOC - 4.3 Unit Tests TOC 143/ 145\n\n[Image 144 OCR]\nVorteile von Tests\n\nv\n\nGesicherte Funktionsweise: Korrektheit der getesteten Einheiten\nbereits wahrend der Entwicklung priifen\n\nWeniger Fehler: Unerwiinschte Seiteneffekte friih finden\nUnterstiitzung beim Refactoring: Quellcode ohne Angst andern\n\nReflektierte Strukturierung: Code Design gut iiberlegen\n\nvvvy\n\nZufriedenheit bei der Entwicklung: dem Ergebnis vertrauen und\nmanuelles Testen vermeiden\n\n> Code testgetrieben entwicklen (TDD, Test-driven development):\n> Zuerst den Test schreiben ( test_onlinestatus.py )\n\n> Danach die eigentliche Implementierung ( onlinestatus.",
    "py )\n\nKurzfristig: die Entwicklung verlangsamt sich\nLangfristig: der Code wird stabiler und die Struktur verbessert\n\nPython MOOC - 4.3 Unit Tests TOC 144/ 145\n\n[Image 145 OCR]\nZusammenfassung fiir 4.3 Unit Tests wa\n\nCode systematisch priifen:\n> abgeschlossene Einheiten (Units) auf korrekte Funktion iiberpriifen\nimport unittest # Modul importieren\nfrom datei import funktion # Code importieren\nclass FunktionsTest (unittest.TestCase) :\ndef test_rueckgabe(self): # Testfall definieren\nself .assertEqual(funktion(0), \"Sollwert\")\n\"\n\nif __name__ == main__\n\n\"\nunittest.main()\n> Fur die Test-Klasse immer (unittest.TestCase) angeben\n\n> Jede Test-Methode mit test_ beginnen und (self) angeben\n> Weiterfiihrendes Material: Beispiele unterschiedlicher Testverfahren,\nUnittest-Dokumentation (English), assert-Methoden\n\nMelde unklare Aufgaben im Forum. Markiere die Inhalte dieser Lektion in deiner RefCard. Python MOOC - 4.3 Unit Tests TOC 145/ 145"
]